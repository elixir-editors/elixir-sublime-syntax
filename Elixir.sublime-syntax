%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Elixir
file_extensions:
  - ex
  - exs
first_line_match: ^#!\s*/.*\b(?:elixirc?|iex)
scope: source.elixir

variables:
  module_name: \b[A-Z][a-zA-Z\d_]*\b
  atom_id_suffix: '[\w@]*[?!]?'
  atom_id: (?>[[:alpha:]_]{{atom_id_suffix}})
  identifier: (?>[[:lower:]_]\w*[?!]?)
  not_id_key_suffix: \b(?!{{atom_id_suffix}}:|[?!])

  closing_token: (?>[,;)}\]#]|%>|$|\b(?>catch|after|rescue|else|end){{not_id_key_suffix}})
  binary_operator: (?>(?<!\s)[\[(]|~~~|[*=/|\\>.]|<(?!<[^<])|\^\^|&&|(?<!\s)[-+]\S|[-+][-+>\s]|::|$|!=|(?>and|x?or|when|in|not\s+in){{not_id_key_suffix}})
  not_closing_or_operator: (?!\s*(?>{{closing_token}}|{{binary_operator}}))

  operators: =(?>~|=?=?)|!==?|!|<<<|>>>|~~~|::|<~>|<?<~|~>>?|<?\|>|/|\\\\|\*|\.{1,3}|[<>]=|[<-][->]?|>|&&?&?|\+\+?|\|{1,3}|@|{}|\[\]|\^\^{0,2}

  special_atom: (?><<>>|%{}|%)
  atom_symbol: (?>{{atom_id}}|{{special_atom}}|{{operators}})

contexts:
  main:
    - include: core_syntax

  fn_block:
    - match: \bfn{{not_id_key_suffix}}
      scope: keyword.control.elixir punctuation.section.block.begin.elixir
      push:
        - include: first_fn_header
        # - match: |
        #     (?x)
        #     (?=
        #       (?:
        #         (
        #           \( (?: [^()]++   | \g<-1> )* \) |
        #           \[ (?: [^\[\]]++ | \g<-1> )* \] |
        #           \{ (?: [^{}]++   | \g<-1> )* \}
        #         ) |
        #         [^{(\[]+
        #       )*
        #       =>
        #     )
        #   push: first_fn_header

        # TODO: try to match parameters according to indentation:
        # - match: (?=->)
        #   set: first_fn_header
        # - match: \s+\n?
        #   set:
        #     - match: (\s+)(?!\s)
        #       set:
        #         - match: \1
        #           push:
        #             - match: (?=->)
        #               scope: punctuation.definition.parameters.end.elixir
        #               set:
        #                 - include: block_end_pop
        #                 - include: core_syntax
        #             - include: fn_parameters
        # - include: block_end_pop
        # - include: core_syntax

  first_fn_header:
    # - meta_scope: meta.function.parameters.elixir
    - match: (?=->|\bwhen{{not_id_key_suffix}})
      set:
        - include: block_end_pop
        - include: core_syntax
    - include: fn_parameters

  function_header_pop:
    - match: \bunquote(?=\s*\()
      scope: variable.function.elixir
      set: [function_params_pop, arguments_pop, spaces_pop]
    - match: '{{identifier}}(?=\s){{not_closing_or_operator}}'
      scope: entity.name.function.elixir
      set:
        - match: (?={{atom_symbol}}:(?!:))
          pop: true
        - include: parameters
        - include: non_space_or_eol_pop
    - match: '{{identifier}}(?=\s*([(,]|do{{not_id_key_suffix}}|$))'
      scope: entity.name.function.elixir
      set: function_params_pop
    - match: (?=\S)
      set:
        - match: ({{operators}}|\bin{{not_id_key_suffix}})
          scope: entity.name.function.elixir
          set:
            - include: parameters
            - include: non_space_or_eol_pop
        - match: (?=\()
          set: function_params_pop
        - include: parameters
        - include: non_space_or_eol_pop

  function_params_pop:
    - match: '[^\S\n\r]'
    - match: \(
      scope: punctuation.definition.parameters.begin.elixir
      set:
        - meta_scope: meta.function.parameters.elixir
        - match: \)
          scope: punctuation.definition.parameters.end.elixir
          set: function_post_params_pop
        - include: parameters
    - include: empty_pop

  fn_parameters:
    # NB: no default parameters in fn blocks
    - match: \\\\(?!:)
      scope: keyword.operator.other.elixir invalid.illegal.default-operator.elixir
    - include: parameters

  parameters:
    - include: atom_keyword
    - include: elixir_keywords
    - match: \b__MODULE__{{not_id_key_suffix}}
      scope: variable.language.special-form.elixir
    - match: |
        (?x)
        (?>((?<![^.]\.)_{{identifier}}?)|({{identifier}}))
        (?=\s*(?>[,)}\]=|\\]|\.\.|::|->|\b(when|in|do){{not_id_key_suffix}}|$))
      captures:
        1: variable.parameter.unused.elixir
        2: variable.parameter.elixir
    - match: \,(?=\s*\))
      scope: invalid.illegal.separator.elixir
    - match: \,
      scope: punctuation.separator.elixir
    - match: \\\\(?!:)
      scope: keyword.operator.other.elixir
      push:
        - match: (?=[,)]|\b(?>when|do){{not_id_key_suffix}})
          pop: true
        - include: core_syntax
    - include: paren_param
    - include: tuple_param
    - include: list_param
    - include: map_param
    - include: binary_string_param
    - include: core_syntax

  paren_param:
    - match: \(
      scope: punctuation.definition.parameters.begin.elixir
      set:
        - meta_scope: meta.function.parameters.elixir
        - match: \)
          scope: punctuation.definition.parameters.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: parameters

  tuple_param:
    - match: \{
      scope: punctuation.section.sequence.begin.elixir
      push:
        - meta_scope: meta.sequence.tuple.elixir
        - match: \}
          scope: punctuation.section.sequence.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: parameters

  list_param:
    - match: \[
      scope: punctuation.section.brackets.begin.elixir
      push:
        - meta_scope: meta.brackets.elixir
        - match: \]
          scope: punctuation.section.brackets.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: parameters

  map_param:
    - match: \%
      scope: punctuation.section.mapping.begin.elixir
      push:
        - match: \b_{{not_id_key_suffix}}
          scope: variable.parameter.unused.elixir
          set: map_param_body_pop
        - include: alias_names
        - include: map_param_body_pop

  map_param_body_pop:
    - match: \{
      scope: punctuation.section.mapping.begin.elixir
      set:
        - meta_scope: meta.mapping.elixir
        - match: \}
          scope: punctuation.section.mapping.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.mapping.elixir
        - include: parameters
    - include: non_space_or_eol_pop

  binary_string_param:
    - match: '>>(?!>)'
      scope: punctuation.definition.string.binary.end.elixir invalid.illegal.elixir
    - match: <<(?!<)
      scope: punctuation.definition.string.binary.begin.elixir string.other.elixir
      push:
        - meta_scope: meta.string.binary.elixir
        - include: binary_string_body
        - include: parameters

  function_post_params_pop:
    - match: \,
      scope: punctuation.separator.elixir
      set:
        # Commented out. May be annoying during typing.
        # - match: \bdo{{not_id_key_suffix}}
        #   comment: compiler reports this as an unexpected token; doesn't try to find matching "end"
        #   scope: invalid.illegal.keyword.elixir
        - match: \bdo(:)(?!:)|$
          scope: constant.other.keyword.elixir
          captures:
            1: punctuation.definition.constant.elixir
          pop: true
        - include: core_syntax
    - include: do_block_pop
    - include: core_syntax
    - include: eol_pop

  numeric:
    - match: |
        (?x)
        \b(
          0x\h[\h_]* |
          0b[01](?:_?[01])* |
          0o[0-7](?:_?[0-7])* |
          \d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][-+]?\d(?:_?\d)*)?
        )(\w*)\b
      comment: (?:_?\d)* because double or trailing '_' are invalid
      captures:
        1: constant.numeric.elixir
        2: invalid.illegal.numeric.elixir

  binary_string:
    - match: '>>(?!>)'
      scope: punctuation.definition.string.binary.end.elixir invalid.illegal.elixir
    - match: <<(?!<)
      scope: punctuation.definition.string.binary.begin.elixir string.other.elixir
      push:
        - meta_scope: meta.string.binary.elixir
        - include: binary_string_body
        - include: core_syntax

  binary_string_body:
    - match: '>>(?!>)'
      scope: punctuation.definition.string.binary.end.elixir string.other.elixir
      pop: true
    - match: (\,)\s*(\,)
      captures:
        1: invalid.illegal.separator.binary.elixir
        2: invalid.illegal.separator.binary.elixir
    - match: \,
      scope: punctuation.separator.binary.elixir
    - match: '::(?!:)'
      scope: keyword.other.colon.elixir
      push:
        - match: (?:[a-z][\w-]*)\s*(?>\(\s*(?>(\d+)|({{identifier}}))?\s*\))?
          scope: storage.type.binary.elixir
          captures:
            1: constant.numeric.elixir
            2: variable.other.elixir
        - match: (?=\()
          push:
            - meta_scope: storage.type.elixir
            - include: arguments_pop
        - match: \d+|[-_*]
          scope: storage.type.binary.elixir
        - include: non_space_pop

  escaped_char:
    - match: \\x\h{2}
      scope: constant.character.escape.hex.elixir
    # Avoid possibly matching closing string delimiter: [^'"/)\]}>]
    - match: \\x(?:\h|([^'"/)\]}>])){1,2}
      scope: constant.character.escape.hex.elixir
      captures:
        1: invalid.illegal.escape.hex.elixir
        2: invalid.illegal.escape.hex.elixir
    - match: \\u(?:\h{4}|{\h{1,6}})
      scope: constant.character.escape.unicode.elixir
    - match: \\u(?:{}|{?[^'"/)\]}>]{1,6}}?)
      scope: invalid.illegal.escape.unicode.elixir
    - match: \\.
      scope: constant.character.escape.char.elixir

  interpolated_elixir:
    - match: (?=#{)
      push:
        # TODO: could use 1, but need to adjust scopes in rules using escaped_or_interpolated.
        - clear_scopes: true
        - match: '#{'
          scope: punctuation.section.interpolation.begin.elixir
          set:
            - clear_scopes: true
            - meta_content_scope: source.elixir.embedded
            - meta_scope: source.elixir meta.string.elixir meta.interpolation.elixir
            - match: \}
              scope: punctuation.section.interpolation.end.elixir
              pop: true
            - include: core_syntax

  escaped_or_interpolated:
    - include: escaped_char
    - include: interpolated_elixir

  regex_elixir:
    - include: scope:source.regexp.elixir

  regex_or_interpolated:
    - include: interpolated_elixir
    - include: regex_elixir


  simple_string:
    - match: "'"
      comment: single quoted string (allows for interpolation)
      scope: punctuation.definition.string.begin.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.single.elixir
        - match: "'"
          scope: punctuation.definition.string.end.elixir
          pop: true
        - include: escaped_or_interpolated

    - match: \"
      comment: double quoted string (allows for interpolation)
      scope: punctuation.definition.string.begin.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.double.elixir
        - match: \"
          scope: punctuation.definition.string.end.elixir
          pop: true
        - include: escaped_or_interpolated

  heredoc_regex_interpolated:
    - match: (""")(.*)\n
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        - include: heredoc_string_closing_double_pop
        - match: ''
          push: regex_elixir
          with_prototype:
            - include: interpolated_elixir
            - match: (?=^(?>\\.|[^"])*?""")
              pop: true

    - match: (''')(.*)\n
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        - include: heredoc_string_closing_single_pop
        - match: ''
          push: regex_elixir
          with_prototype:
            - include: interpolated_elixir
            - match: (?=^(?>\\.|[^'])*?''')
              pop: true

  heredoc_regex_raw:
    - match: (""")(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        # TODO: not yet committed. simplifies rules because no interpolation is needed.
        # - include: regex_elixir
        - include: heredoc_string_closing_double_pop
        - match: ''
          push: regex_elixir
          with_prototype:
            - match: (?=^(?>\\.|[^"])*?""")
              pop: true

    - match: (''')(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        # TODO: not yet committed. simplifies rules because no interpolation is needed.
        # - include: regex_elixir
        - include: heredoc_string_closing_single_pop
        - match: ''
          push: regex_elixir
          with_prototype:
            - match: (?=^(?>\\.|[^'])*?''')
              pop: true

  heredoc_string_interpolated:
    - match: (""")(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        - include: escaped_or_interpolated
        - include: heredoc_string_closing_double_pop

    - match: (''')(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        - include: escaped_or_interpolated
        - include: heredoc_string_closing_single_pop

  heredoc_string_raw:
    - match: (""")(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        - include: heredoc_string_closing_double_pop
        - match: \\"
          scope: constant.character.escape.char.elixir

    - match: (''')(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        - include: heredoc_string_closing_single_pop
        - match: \\'
          scope: constant.character.escape.char.elixir

  heredoc_string_closing_double_pop:
    - match: ^\s*((?>\\.|[^"])*?)\s*(""")
      captures:
        1: invalid.illegal.closing-heredoc.elixir
        2: punctuation.definition.string.end.elixir
      pop: true

  heredoc_string_closing_single_pop:
    - match: ^\s*((?>\\.|[^'])*?)\s*(''')
      captures:
        1: invalid.illegal.closing-heredoc.elixir
        2: punctuation.definition.string.end.elixir
      pop: true

  string:
    - include: heredoc_string_interpolated
    - include: simple_string
    - include: binary_string

    - match: (?x) (~[a-zA-Z])\n | ~[a-zA-Z]([^{\[<(/|"'])
      comment: catch invalid sigils first
      scope: meta.string.elixir storage.type.string.elixir
      captures:
        1: invalid.illegal.sigil-string.elixir
        2: invalid.illegal.string-delimiter.elixir

    # Look for 'a' behind the closing delimiter.
    # Bracket delimiters are not matched yet: <>, {}, [] and ()
    - match: (?=~w([/|"'])(?>\\.|(?!\1).)*\1a)
      comment: highlight words as atoms
      push:
        - match: (~w)(.)
          captures:
            1: storage.type.string.elixir
            2: string.quoted.other.atom.elixir punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir
            - meta_content_scope: string.quoted.other.atom.elixir constant.other.symbol.atom.elixir
            - match: \s+
              push:
                - clear_scopes: 1
                - include: empty_pop
            - include: escaped_or_interpolated
            - match: (\2)(a)
              captures:
                1: string.quoted.other.atom.elixir punctuation.definition.string.end.elixir
                2: string.quoted.modifiers.elixir storage.type.string.elixir
              pop: true

    - match: ~L
      comment: LiveView
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^(?>\\.|[^"])*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double_pop
            - match: ''
              push: scope:text.html.elixir
              with_prototype:
                - include: interpolated_elixir
                - match: \\"
                  scope: constant.character.escape.char.elixir
                - match: (?=^(?>\\.|[^"])*?""")
                  pop: true

    - match: ~y
      comment: YAML with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^(?>\\.|[^"])*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double_pop
            - match: ''
              push: scope:source.yaml
              with_prototype:
                - include: interpolated_elixir
                - match: (?=^(?>\\.|[^"])*?""")
                  pop: true

    - match: ~Y
      comment: YAML raw
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^(?>\\.|[^"])*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double_pop
            - match: ''
              push: scope:source.yaml
              with_prototype:
                - match: \\"
                  scope: constant.character.escape.char.elixir
                - match: (?=^(?>\\.|[^"])*?""")
                  pop: true

    - match: ~j
      comment: JSON with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^(?>\\.|[^"])*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double_pop
            - match: ''
              push: scope:source.json
              with_prototype:
                - include: interpolated_elixir
                - match: (?=^(?>\\.|[^"])*?""")
                  pop: true

    - match: ~J
      comment: JSON raw
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^(?>\\.|[^"])*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double_pop
            - match: ''
              push: scope:source.json
              with_prototype:
                - match: \\"
                  scope: constant.character.escape.char.elixir
                - match: (?=^(?>\\.|[^"])*?""")
                  pop: true

    - match: ~r
      comment: regex sigil string with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_regex_interpolated
            - match: ''
              set: string_modifiers_and_pop
        - match: \"
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: \"
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=")
                  pop: true
        - match: \'
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: \'
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=')
                  pop: true
        - match: /
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: /
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=/)
                  pop: true
        - match: \|
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: \|
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=\|)
                  pop: true
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_curly
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=})
                  pop: true
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_square
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=])
                  pop: true
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_angle
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=>)
                  pop: true
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_round
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=\))
                  pop: true

    - match: ~R
      comment: regex sigil string without interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_regex_raw
            - match: ''
              set: string_modifiers_and_pop
        - match: \"
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: \"
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=")
                  pop: true
        - match: \'
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: \'
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=')
                  pop: true
        - match: /
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: /
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=/)
                  pop: true
        - match: \|
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: \|
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=\|)
                  pop: true
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_curly
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=})
                  pop: true
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_square
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=])
                  pop: true
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_angle
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=>)
                  pop: true
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_round
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=\))
                  pop: true

    - match: ~[a-z]
      comment: with sigil and with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_string_interpolated
            - match: ''
              set: string_modifiers_and_pop
        - match: (?=[/|"'])
          set:
            - meta_scope: meta.string.elixir
            # (?<=[a-z]) avoids matching again after the closing delimiter. E.g.: ~s||//
            - match: (?<=[a-z])([/|"'])
              captures:
                1: string.quoted.other.literal.lower.elixir punctuation.definition.string.begin.elixir
              push:
                - meta_content_scope: string.quoted.other.literal.lower.elixir
                - match: \1
                  scope: string.quoted.other.literal.lower.elixir punctuation.definition.string.end.elixir
                  pop: true
                - include: escaped_or_interpolated
            - match: ''
              set: string_modifiers_and_pop
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_curly
            - include: escaped_or_interpolated
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_square
            - include: escaped_or_interpolated
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_angle
            - include: escaped_or_interpolated
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_round
            - include: escaped_or_interpolated

    - match: ~[A-Z]
      comment: with sigil and without interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_string_raw
            - match: ''
              set: string_modifiers_and_pop
        - match: (?=[/|"'])
          set:
            - meta_scope: meta.string.elixir
            # (?<=[A-Z]) avoids matching again after the closing delimiter. E.g.: ~S||//
            - match: (?<=[A-Z])([/|"'])
              captures:
                1: string.quoted.other.literal.upper.elixir punctuation.definition.string.begin.elixir
              push:
                - meta_content_scope: string.quoted.other.literal.upper.elixir
                - match: \1
                  scope: string.quoted.other.literal.upper.elixir punctuation.definition.string.end.elixir
                  pop: true
                - match: \\[/|"']
                  scope: constant.character.escape.char.elixir
            - match: ''
              set: string_modifiers_and_pop
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_curly
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_square
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_angle
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_round

  string_closing_curly:
    - match: \\\}
      scope: constant.character.escape.char.elixir
    - match: \}
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_closing_square:
    - match: \\\]
      scope: constant.character.escape.char.elixir
    - match: \]
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_closing_angle:
    - match: \\\>
      scope: constant.character.escape.char.elixir
    - match: \>
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_closing_round:
    - match: \\\)
      scope: constant.character.escape.char.elixir
    - match: \)
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_modifiers:
    - match: '[a-zA-Z]+'
      scope: meta.string.elixir string.quoted.modifiers.elixir storage.type.string.elixir
    - match: \w+
      scope: invalid.illegal.non-ascii-modifier.elixir

  string_modifiers_and_pop:
    - include: string_modifiers
    - include: empty_pop

  def_blocks:
    - match: \bdefmodule{{not_id_key_suffix}}
      scope: keyword.control.module.elixir
      push:
        - meta_scope: meta.namespace.module.elixir
        - include: defmodule_1st_argument
        - match: \(
          scope: punctuation.section.arguments.begin.elixir
          push:
            - meta_scope: meta.function-call.arguments.elixir
            - include: arguments_closing_pop
            - match: \,
              scope: punctuation.separator.arguments.elixir
              set:
                - include: arguments_closing_pop
                - include: core_syntax
            - include: defmodule_1st_argument
        - include: eol_pop
    - match: \bdefprotocol{{not_id_key_suffix}}
      scope: keyword.control.protocol.elixir
      push:
        - meta_scope: meta.namespace.protocol.elixir
        - include: do_block_pop
        - include: module_namespaces
        - include: eol_pop
    - match: \bdefimpl{{not_id_key_suffix}}{{not_closing_or_operator}}
      scope: keyword.control.implementation.elixir
      push:
        - meta_scope: meta.namespace.implementation.elixir
        - match: (?=\s)
          set: arguments_ws_pop
        - include: empty_pop
    - match: \bdef(?>delegate|macro|guard|){{not_id_key_suffix}}{{not_closing_or_operator}}
      scope: keyword.declaration.function.public.elixir
      push: function_header_pop
    - match: \bdef(?>delegate|macro|guard|)p{{not_id_key_suffix}}{{not_closing_or_operator}}
      scope: keyword.declaration.function.private.elixir
      push: function_header_pop

  defmodule_1st_argument:
    - include: do_block_pop
    # E.g.: defmodule MyApp do ... end
    - include: module_namespaces
    # E.g.: defmodule :"Elixir.ModuleTest.RawModule" do ... end
    - include: atom_symbol
    # E.g.: defmodule __MODULE__.NonAtomAlias do ... end
    - include: special_form
    # E.g.: defmodule unquote(name) do ... end
    - include: modules_or_identifiers_or_calls

  do_block_pop:
    - match: \bdo{{not_id_key_suffix}}
      scope: keyword.control.elixir punctuation.section.block.begin.elixir
      set:
        - meta_scope: meta.block.elixir
        - include: block_end_pop
        - include: core_syntax

  do_block:
    # NB: Commented out due to EEx templates: <%= if x do %>...<% end %>
    # - match: \bend{{not_id_key_suffix}}
    #   scope: invalid.illegal.block-end.elixir
    - match: (?=\bdo{{not_id_key_suffix}})
      push: do_block_pop

  block_end_pop:
    - match: \bend{{not_id_key_suffix}}
      scope: keyword.control.elixir punctuation.section.block.end.elixir
      pop: true

  module_names:
    - match: (?={{module_name}})
      push:
        - meta_scope: meta.path.modules.elixir
        - match: '{{module_name}}'
          scope: constant.other.module.elixir
        - include: module_accessor_or_pop

  module_names_pop:
    - match: \s+(?!$)
    # - match: '[^\S\r\n]+'
    - include: module_names
    - include: empty_pop

  module_namespaces:
    # TODO: should also handle: defmodule :"Elixir.ModuleTest.RawModule" do ... end
    - match: (?={{module_name}}|:{{atom_id}})
      push:
        - meta_scope: meta.namespace.elixir
        - match: (?=:{{atom_id}}\s*\.)
          # TODO: use "set"? otherwise :one.:two is allowed.
          push:
            - include: atom_symbol
            - match: (?=\.)
              pop: true
        - match: '{{module_name}}(?=\s*\.)'
          scope: constant.other.module.elixir
        - match: '(:)({{atom_id}})'
          scope: constant.other.symbol.elixir
          captures:
            1: punctuation.definition.constant.begin.elixir
            2: entity.name.namespace.elixir
        - match: '{{module_name}}'
          scope: entity.name.namespace.elixir
        - include: module_accessor_or_pop

  module_accessor_or_pop:
    - match: \s+(?!$)
    - match: \.
      scope: punctuation.accessor.elixir
    - include: empty_pop

  module_function_call_pop:
    - match: ({{module_name}})\s*(\.)\s*({{identifier}}|{{operators}})
      comment: always a function call after a module
      captures:
        1: constant.other.module.elixir
        2: punctuation.accessor.dot.elixir
        3: variable.function.elixir
      set:
        - match: (?={{not_closing_or_operator}})
          set:
            - match: (?=\()
              set: [dot_accessor_or_pop, arguments_pop]
            - include: arguments_ws_pop
        - include: empty_pop

  identifier_operator_call_pop:
    - match: (?>{{identifier}}|{{operators}})(?=(?:\s*\.\s*)?\(|{{not_closing_or_operator}})
      scope: variable.function.elixir
      set:
        - match: \s*(\.)(?!\.)
          captures:
            # TODO: better scope?
            1: punctuation.accessor.dot.elixir
        - match: (?=\()
          set: [dot_accessor_or_pop, arguments_pop]
        - include: arguments_ws_pop
        - include: empty_pop

  quoted_remote_call_pop:
    - match: \"
      scope: punctuation.definition.constant.begin.elixir
      set:
        - match: \\\"
          scope: constant.character.escape.char.elixir
        - match: \"
          scope: punctuation.definition.constant.end.elixir
          set:
            - match: (?=\()
              set: [dot_accessor_or_pop, arguments_pop]
            - include: empty_pop
        - match: \\?[^"]
          scope: variable.function.elixir
    - match: \'
      scope: punctuation.definition.constant.begin.elixir
      set:
        - match: \\\'
          scope: constant.character.escape.char.elixir
        - match: \'
          scope: punctuation.definition.constant.end.elixir
          set:
            - match: (?=\()
              set: [dot_accessor_or_pop, arguments_pop]
            - include: empty_pop
        - match: \\?[^']
          scope: variable.function.elixir

  modules_or_identifiers_or_calls:
    - match: (?={{module_name}}|{{identifier}})
      push:
        - meta_scope: meta.path.modules-identifiers.elixir
        - include: module_function_call_pop
        - include: identifier_operator_call_pop
        - match: '{{module_name}}'
          scope: constant.other.module.elixir
          set: dot_accessor_or_pop
        - match: _{{identifier}}?
          scope: variable.other.unused.elixir
          set: dot_accessor_or_pop
        - match: '{{identifier}}'
          scope: variable.other.elixir
          set: dot_accessor_or_pop

  dot_accessor:
    - match: \.(?!\.)
      scope: punctuation.accessor.dot.elixir
      push:
        - match: (?>{{identifier}}|{{operators}})(?=\s*do{{not_id_key_suffix}})
          comment: avoids matching 'xyz' as a function call, e.g. "func 1, 2, map.xyz do ... end"
          scope: variable.other.member.elixir
          pop: true
        - include: module_function_call_pop
        - include: identifier_operator_call_pop
        - include: quoted_remote_call_pop
        - match: (?=\s*\()
          set: [dot_accessor_or_pop, arguments_pop, spaces_pop]
        - match: '{{identifier}}|{{operators}}'
          scope: variable.other.member.elixir
          set: dot_accessor_or_pop
        - match: '{{module_name}}'
          scope: constant.other.module.elixir
          set: dot_accessor_or_pop
        - include: non_space_pop

  dot_accessor_or_pop:
    - include: dot_accessor
    - include: non_space_or_eol_pop


  module_attribute:
    - match: '@'
      scope: keyword.operator.attribute.elixir
      push: module_attribute_pop

  module_attribute_pop:
    - match: (?!{{identifier}}(?!{{atom_id_suffix}}:))
      set:
        - match: '[A-Z]'
          scope: invalid.illegal.attribute.elixir
        - include: empty_pop

    # Special attributes:
    - match: (?>(?>module|type|short)?doc)(?=\(|{{not_closing_or_operator}})
      scope: support.attr.doc.elixir
      set:
        - meta_content_scope: comment.block.documentation.elixir
        - include: markdown_comment
        - include: non_space_or_eol_pop

    - match: (?>derive|deprecated|impl|file|behaviour|vsn|(?>before_|after_)?compile|dialyzer|external_resource|on_(?>definition|load))(?=\(|{{not_closing_or_operator}})
      scope: support.attr.elixir
      pop: true
    - match: (?>spec|(?:macro)?callback)(?=\(|{{not_closing_or_operator}})
      scope: keyword.declaration.type.elixir
      set:
        - match: '{{identifier}}'
          scope: variable.other.type.elixir
          pop: true
        - include: non_space_pop
    - match: (?>typep?|opaque)(?=\(|{{not_closing_or_operator}})
      scope: keyword.declaration.type.elixir
      set:
        - match: '{{identifier}}'
          scope: entity.name.type.elixir
          pop: true
        - include: non_space_pop

    # Regular attributes:
    - match: '{{identifier}}(?=\(|{{not_closing_or_operator}})'
      comment: definition
      scope: entity.name.constant.elixir
      pop: true
    - match: '{{identifier}}'
      comment: reference
      scope: variable.other.attribute.elixir
      pop: true

  markdown_comment:
    - match: (""")(.*)\n
      captures:
        1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: (?=^\s*""")
          set:
            - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
            - include: heredoc_string_closing_double_pop
        - include: escaped_or_interpolated
        - include: iex_prompt
        - include: elixir_markdown
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?=^\s*"""|(?<=\s{4})(?:iex.*?>|```\s*elixir\b|(?>cond|receive|try)\s+do\b|def(?>module|macro|p|){{not_id_key_suffix}})|\\|#{)

    - match: \"
      scope: punctuation.definition.string.begin.elixir string.quoted.double.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: \"
          scope: punctuation.definition.string.end.elixir string.quoted.double.elixir
          pop: true
        - include: escaped_or_interpolated
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?="|\\|#{)

    - match: ~S(""")(.*)\n
      scope: meta.string.elixir storage.type.string.elixir
      captures:
        1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: (?=^\s*""")
          set:
            - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
            - include: heredoc_string_closing_double_pop
        - include: iex_prompt
        - include: elixir_markdown
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?=^\s*"""|(?<=\s{4})(?:iex.*?>|```\s*elixir\b|(?>cond|receive|try)\s+do\b|def(?>module|macro|p|){{not_id_key_suffix}}))

    - match: ~S(''')(.*)\n
      scope: meta.string.elixir storage.type.string.elixir
      captures:
        1: punctuation.definition.string.begin.elixir string.quoted.triple.single.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: (?=^\s*''')
          set:
            - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
            - include: heredoc_string_closing_single_pop
        - include: iex_prompt
        - include: elixir_markdown
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?=^\s*'''|(?<=\s{4})(?:iex.*?>|```\s*elixir\b|(?>cond|receive|try)\s+do\b|def(?>module|macro|p|){{not_id_key_suffix}}))

  iex_prompt:
    - match: (?<=\s{4})(?=(?>(?>cond|receive|try)\s+do|def(?>module|macro|p|)){{not_id_key_suffix}})
      push:
        - clear_scopes: true
        - meta_scope: meta.interpolation.elixir markup.raw.block.markdown markup.raw.block.elixir
        - include: scope:source.elixir
        - match: $\s
          scope: markup.raw.block.elixir
          pop: true
    - match: (?<=\s{4})(iex).*?(>)
      captures:
        1: keyword.other.elixir
        2: keyword.other.elixir
      push:
        - clear_scopes: true
        - meta_scope: meta.interpolation.elixir markup.raw.block.markdown markup.raw.block.elixir
        # NB: needs with_prototype or embed to work
        - match: ^\s*(\.{3})(>)
          scope: keyword.other.elixir
        - include: scope:source.elixir
        - match: $\s
          scope: markup.raw.block.elixir
          pop: true

  elixir_markdown:
    - match: \s*(```)\s*(elixir)\b
      captures:
        1: punctuation.definition.code-block.begin.markdown
        2: constant.other.language-name.elixir
      push:
        - clear_scopes: 2
        - meta_scope: meta.interpolation.elixir markup.raw.block.markdown markup.raw.block.elixir
        - match: '```\n?'
          scope: punctuation.definition.code-block.end.markdown
          pop: true
        # NB: with_prototype causes "25000 context sanity limit" error.
        # - match: ''
        #   set: core_syntax
        #   with_prototype:
        #     - match: '```\n?'
        #       scope: punctuation.definition.code-block.end.markdown
        #       pop: true
        - include: core_syntax

  operator:
    - match: '::'
      scope: keyword.operator.colon.elixir
    - match: <~
      scope: keyword.operator.arrow-tilde.elixir
    - match: <-|->
      scope: keyword.operator.arrow.elixir
    - match: <>
      scope: keyword.operator.binary-concat.elixir
    - match: \|>
      scope: keyword.operator.pipe.elixir
    - match: --
      scope: keyword.operator.list-diff.elixir
    - match: \+\+
      scope: keyword.operator.list-concat.elixir
    - match: \.{3}
      comment: can appear in @type declarations
      scope: keyword.operator.ellipsis.elixir
    - match: \.\.
      scope: keyword.operator.range.elixir
    - match: =>
      scope: keyword.operator.map-pair.elixir
    - match: (?>\|\|\||&&&|\^\^\^|<<<|>>>|~~~)
      scope: keyword.operator.bitwise.elixir
    - match: \|
      scope: keyword.operator.cons.elixir
    - match: \\\\
      scope: keyword.operator.default.elixir
    - match: (?>[!=]=|[<>])=?
      scope: keyword.operator.comparison.elixir
    - match: \b(?>not|and|or|xor){{not_id_key_suffix}}|!|\|\||&&
      scope: keyword.operator.logical.elixir
    - match: '[-+*/]'
      scope: keyword.operator.arithmetic.elixir
    - match: =~
      scope: keyword.operator.regex.elixir
    - match: =
      scope: keyword.operator.match.elixir
    - match: ;
      scope: keyword.operator.semicolon.elixir
    - match: \^
      scope: keyword.operator.pin.elixir

  tuple:
    - match: \}
      scope: invalid.illegal.stray-closing-brace.elixir
    - match: \{
      scope: punctuation.section.sequence.begin.elixir
      push:
        - meta_scope: meta.sequence.tuple.elixir
        - match: \}
          scope: punctuation.section.sequence.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: core_syntax

  list:
    - match: \]
      scope: invalid.illegal.stray-closing-bracket.elixir
    - match: \[
      scope: punctuation.section.brackets.begin.elixir
      push:
        - meta_scope: meta.brackets.elixir
        - match: \]
          scope: punctuation.section.brackets.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: core_syntax

  map:
    - match: \%
      scope: punctuation.section.mapping.begin.elixir
      push:
        - match: \b_{{not_id_key_suffix}}
          scope: variable.other.unused.elixir
          set: map_body_pop
        - include: alias_names
        - include: map_body_pop

  map_body_pop:
    - match: \{
      scope: punctuation.section.mapping.begin.elixir
      set:
        - meta_scope: meta.mapping.elixir
        - match: \}
          scope: punctuation.section.mapping.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.mapping.elixir
        - include: core_syntax
    - include: non_space_or_eol_pop

  parens:
    - match: \)
      scope: invalid.illegal.stray-closing-parenthesis.elixir
    - match: \(
      scope: punctuation.section.parens.begin.elixir
      push:
        - meta_scope: meta.parens.elixir
        - match: \)
          scope: punctuation.section.parens.end.elixir
          pop: true
        - include: core_syntax

  alias:
    - match: \balias\b{{not_closing_or_operator}}
      scope: keyword.control.elixir
      push:
        - include: alias_names
        - match: \,
          scope: punctuation.separator.arguments.elixir
          set:
            - include: alias_arg
            - match: \,
              scope: punctuation.separator.arguments.elixir
            - include: eol_pop
            - include: core_syntax
        - include: eol_pop
        - include: core_syntax

  alias_arg:
    - match: (?=\bas:(?!:))
      scope: punctuation.separator.arguments.elixir
      push:
        - match: as(:)
          scope: constant.other.keyword.elixir
          captures:
            1: punctuation.definition.constant.elixir
          set:
            - match: '{{module_name}}{{not_id_key_suffix}}'
              scope: entity.name.namespace.elixir
            - match: (?=,)
              pop: true
            - include: non_space_or_eol_pop

  alias_names:
    - match: (?=(?>{{module_name}}|\b__MODULE__){{not_id_key_suffix}}|:(?>{{atom_id}}|['"]))
      push:
        - meta_scope: meta.path.modules.elixir
        - include: alias_module_name_pop
        - match: __MODULE__
          scope: variable.language.special-form.elixir
          set: alias_dot_or_pop
        - include: atom_symbol
        - include: alias_dot_or_pop

  alias_module_name_pop:
    - match: '{{module_name}}{{not_id_key_suffix}}'
      scope: constant.other.module.elixir
      set: alias_dot_or_pop

  alias_dot_or_pop:
    - match: \.
      scope: punctuation.accessor.elixir
      set: alias_name_or_tuple_pop
    - include: non_space_or_eol_pop

  alias_name_or_tuple_pop:
    - include: alias_module_name_pop
    - match: \{
      scope: punctuation.section.braces.begin.elixir
      set:
        - match: \}
          scope: punctuation.section.braces.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - match: '{{module_name}}{{not_id_key_suffix}}'
          scope: constant.other.module.elixir
          push: alias_dot_or_pop
        # NB: to avoid messing up the highlighting due to an unfinished alias
        - include: non_space_pop
    - include: non_space_or_eol_pop

  atom_keyword:
    - match: (?>\*\*|\[\]|\^\^|\.)(:)(?!:)
      scope: invalid.illegal.atom-keyword.elixir
      captures:
        1: punctuation.definition.constant.elixir
    - match: |
        (?x)
        (?! ::: | %:(?:{{atom_id}}|['"]) ) # No ::: and %:XYZ{} (it's a map)
        {{atom_symbol}}(:)(?!:)
      comment: keyword symbol
      scope: constant.other.keyword.elixir
      captures:
        1: punctuation.definition.constant.elixir
    # Look for ':' behind the closing apostrophe.
    # TODO: doesn't work for: "abc #{"xyz"}": ...
    - match: (?=(["'])(?>\\.|(?!\1).)*\1:(?!:))
      comment: keyword string
      push:
        - match: (.)
          scope: punctuation.definition.constant.begin.regexp.elixir
          set:
            - meta_scope: constant.other.keyword.double-quoted.elixir
            - include: escaped_or_interpolated
            - match: '\1:'
              scope: punctuation.definition.constant.end.regexp.elixir
              pop: true

  atom_symbol:
    - match: (:){{atom_symbol}}
      comment: atom symbols
      scope: constant.other.symbol.elixir
      captures:
        1: punctuation.definition.constant.begin.elixir
    - match: :'
      scope: punctuation.definition.constant.begin.elixir
      push:
        - meta_scope: constant.other.symbol.single-quoted.elixir
        - match: \'
          scope: punctuation.definition.constant.end.elixir
          pop: true
        - include: escaped_or_interpolated
    - match: :"
      scope: punctuation.definition.constant.begin.elixir
      push:
        - meta_scope: constant.other.symbol.double-quoted.elixir
        - match: \"
          scope: punctuation.definition.constant.end.elixir
          pop: true
        - include: escaped_or_interpolated

  capture:
    - match: \&0
      scope: invalid.illegal.capture.elixir
    - match: \&\d+
      scope: constant.other.capture.elixir
    - match: \&(?=\s*(?>{{module_name}}\s*\.\s*)*(?>{{identifier}}|{{operators}})\s*/\s*\d)
      scope: keyword.operator.capture.elixir
      push:
        - match: (/)\s*(\d+)
          captures:
            1: punctuation.accessor.slash.elixir
            2: constant.numeric.integer.decimal.elixir
          pop: true
        - include: module_names
        - match: '{{identifier}}|{{operators}}'
          scope: variable.other.capture.elixir
    - match: \&
      scope: keyword.operator.capture.elixir

  sql_fragment:
    # See: https://github.com/sublimehq/Packages/blob/3b1923b025db53d67d4fde4baf1360a0c76d7469/SQL/SQL.sublime-syntax#L188
    - match: \b(fragment)\s*(\()
      captures:
        1: support.function.elixir
        2: punctuation.section.parens.begin.elixir
      push:
        - match: \)
          scope: punctuation.section.parens.end.elixir
          pop: true
        # TODO: handle triple quoted strings.
        - match: '"""\n'
          scope: punctuation.definition.string.begin.elixir string.quoted.double.elixir
          push:
            - match: ''
              set: scope:source.sql
              with_prototype:
                - include: sql_embedded
                - match: '"""'
                  scope: punctuation.definition.string.end.elixir string.quoted.double.elixir
                  pop: true
        - match: \"
          scope: punctuation.definition.string.begin.elixir string.quoted.double.elixir
          push:
            - match: ''
              set: scope:source.sql
              with_prototype:
                - include: sql_embedded
                - match: \"
                  scope: punctuation.definition.string.end.elixir string.quoted.double.elixir
                  pop: true
        - include: core_syntax

  sql_embedded:
    - match: |
        (?x)
        \b(
          jsonb_to_tsvector|to_jsonb?|(?>array|row)_to_json|jsonb?_build_array|jsonb?(?:_build)?_object |
          jsonb?_(?>array_(?>length|elements(?:_text)?)|each(?:_text)?|extract_path(?:_text)?|object_keys|populate_record(?:set)?|typeof|to_record(?:set)?|strip_nulls) |
          jsonb_(?>set|insert|pretty|path_exists|path_match|path_query(?>_array|_first)?)
        )\b
      scope: support.function.sql
    - match: '(?i)\b(now|(?>array|string|jsonb?)_agg|random|row_number|to_tsquery|to_tsvector|setweight|replace)\b'
      scope: support.function.sql
    - match: '(?i)\b(ANY|OVER|NOT\s+IN|NULLS\s+LAST)\b|::'
      scope: keyword.operator.sql
    - match: '(?<=::)(jsonb?|tsvector)\b'
      scope: storage.type.sql
    - match: ->>?|#>>?|@[>@?]|<@|#-
      comment: Postgres jsonb operators
      scope: keyword.operator.jsonb.sql
    - match: (\\\\)(\?[|&]?)?
      comment: Postgres jsonb operators
      captures:
        1: constant.character.escape.sql
        2: keyword.operator.jsonb.sql
    - match: (?<!\w)\\?\?(?!\w)
      comment: Ecto argument placeholder
      scope: constant.other.placeholder.elixir

  comment:
    - match: (##).*
      scope: comment.line.number-sign.section.elixir
      captures:
        1: punctuation.definition.comment.elixir
    - match: (#).*
      scope: comment.line.number-sign.elixir
      captures:
        1: punctuation.definition.comment.elixir

  char_literal:
    - match: \?$
      scope: invalid.illegal.character-literal.elixir
    - match: \?(?>\\(?>.|\n)|\S|(\s))
      comment: character literal as an integer
      scope: constant.numeric.elixir
      captures:
        1: invalid.illegal.character-literal.elixir

  built-ins:
    - match: |
        (?x)
        (?>
          is_(?>atom|binary|bitstring|boolean|float|function|integer|list|map|nil|number|pid|port|record|reference|tuple|exception) |
          abs|bit_size|byte_size|div|elem|hd|length|map_size|node|rem|round|tl|trunc|tuple_size
        )\b(?=\s*\(|{{not_closing_or_operator}})
      scope: variable.function.built-in.elixir
      push:
        - match: (?=\()
          set: [arguments_pop, spaces_pop]
        - include: arguments_ws_pop
        - include: empty_pop

  arguments_pop:
    - match: \(
      scope: punctuation.section.arguments.begin.elixir
      set:
        - meta_scope: meta.function-call.arguments.elixir
        - include: arguments_closing_pop
        - match: \,
          scope: punctuation.separator.arguments.elixir
        - include: core_syntax

  arguments_closing_pop:
    - match: \)
      scope: punctuation.section.arguments.end.elixir
      pop: true

  arguments_ws_pop:
    - match: \s
      comment: arguments list without parentheses
      scope: punctuation.section.arguments.begin.elixir
      set:
        - meta_scope: meta.function-call.arguments.elixir
        - match: (\,)(?=\s*do{{not_id_key_suffix}})
          scope: invalid.illegal.separator.arguments.elixir
        - match: (\,)(?:\s*$)?
          captures:
            1: punctuation.separator.arguments.elixir
        # NB: needed due to "... #{inspect x} ..." or Repo.all(from p in q, select: p.title)
        - match: '[\n\r]|(?=[})\];]|%>|\b(?>else|end){{not_id_key_suffix}})'
          scope: punctuation.section.arguments.end.elixir
          pop: true
        - match: (?=\bdo{{not_id_key_suffix}})
          set: do_block_pop
        - match: |
            (?x)
            (?=
              (?>
                @\s*{{identifier}} |
                {{identifier}}(?:\s*\.\s*{{identifier}})*
              )
              \s*do{{not_id_key_suffix}}
            )
          comment: prevent matching last argument as a function call
          set:
            - match: (@)\s*({{identifier}})
              comment: reference
              captures:
                1: keyword.operator.attribute.elixir
                2: variable.other.attribute.elixir
            - match: _{{identifier}}?
              scope: variable.other.unused.elixir
            - match: '{{identifier}}'
              scope: variable.other.elixir
            - match: \.
              scope: punctuation.accessor.dot.elixir
            - include: empty_pop
        - include: core_syntax

  special_form:
    - match: \b(__(?>CALLER|ENV|MODULE|DIR|STACKTRACE)__)\b(?![?!])
      scope: variable.language.special-form.elixir

  elixir_keywords:
    - match: \b(?>when|not|in|fn|catch|after|rescue|do|else|end)\b(?![?!])
      comment: fully reserved keywords
      scope: keyword.control.elixir
    - match: \b(?>nil|true|false)\b(?![?!])
      scope: constant.language.elixir

  elixir_functions:
    - match: \b(?>case|for|if|cond|unless|try|receive|defrecord|defstruct|defexception|defoverridable|exit|raise|reraise|throw|import|require|use|using|quote|unquote|super|with)\b{{not_closing_or_operator}}
      scope: keyword.control.elixir
      push: arguments_ws_pop

  spaces_pop:
    - match: \s*
      pop: true

  non_space_pop:
    - match: (?=\S)
      pop: true

  non_space_or_eol_pop:
    - match: (?=\S|$)
      pop: true

  eol_pop:
    - match: $
      pop: true

  empty_pop:
    - match: ''
      pop: true

  core_syntax:
    - include: atom_keyword
    - include: atom_symbol
    - include: numeric
    - include: string
    - include: def_blocks
    - include: do_block
    - include: fn_block
    - include: tuple
    - include: parens
    - include: list
    - include: map
    - include: operator
    - include: capture
    - include: dot_accessor
    - include: alias
    - include: elixir_keywords
    - include: elixir_functions
    - include: special_form
    - include: sql_fragment
    - include: built-ins
    - include: module_attribute
    - include: modules_or_identifiers_or_calls
    - include: comment
    - include: char_literal
