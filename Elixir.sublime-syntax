%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Elixir
file_extensions:
  - ex
  - exs
first_line_match: ^#!\s*/.*\b(?:elixirc?|iex)
scope: source.elixir

variables:
  module_name: \b[A-Z][a-zA-Z0-9_]*\b
  atom_id_suffix: '[\w@]*[?!]?'
  atom_id: (?>[[:alpha:]_]{{atom_id_suffix}})
  identifier: (?>[[:lower:]_]\w*[?!]?)
  not_id_key_suffix: (?!{{atom_id_suffix}}:|[?!])

  closing_token: (?>[,;)}\]#]|%>|$|\b(?>catch|after|rescue|else|end)\b{{not_id_key_suffix}})
  binary_operator: (?>(?<!\s)[\[(]|~~~|[*=/|\\>.]|<(?!<[^<])|\^\^|&&|(?<!\s)[-+]\S|[-+][-+>\s]|::|$|!=|(?>and|x?or|when|in|not\s+in)\b{{not_id_key_suffix}})
  not_closing_or_operator: (?!\s*(?>{{closing_token}}|{{binary_operator}}))

  operators: =(?>~|=?=?)|!==?|!|<<<|>>>|~~~|::|<~>|<?<~|~>>?|<?\|>|/|\\\\|\*|\.{1,3}|[<>]=|[<-][->]?|>|&&?&?|\+\+?|\|{1,3}|@|%?{}|\[\]|\^\^{0,2}
  atom_ops: (?><<>>|%{}|%)

contexts:
  main:
    - include: core_syntax

  fn_block:
    - match: \bfn\b{{not_id_key_suffix}}
      scope: keyword.control.elixir punctuation.section.block.begin.elixir
      push:
        # TODO: try to match parameters according to indentation:
        # - match: (?=->)
        #   set: first_fn_header
        # - match: \s+\n?
        #   set:
        #     - match: (\s+)(?!\s)
        #       set:
        #         - match: \1
        #           push:
        #             - match: (?=->)
        #               scope: punctuation.definition.parameters.end.elixir
        #               set:
        #                 - include: block_end_pop
        #                 - include: core_syntax
        #             - include: fn_parameters

        - include: first_fn_header

        # - include: block_end_pop
        # - include: core_syntax
        # - include: fn_header

  first_fn_header:
    # - meta_scope: meta.function.parameters.elixir
    - match: \bwhen\b{{not_id_key_suffix}}
      scope: keyword.other.elixir
      set:
        - match: (?=->)
          scope: punctuation.definition.parameters.end.elixir
          set:
            - include: block_end_pop
            - include: core_syntax
        - include: block_end_pop
        - include: core_syntax
    - match: (?=->)
      scope: punctuation.definition.parameters.end.elixir
      set:
        - include: block_end_pop
        - include: core_syntax
    # - include: special_form
    # - match: \b(?>nil|true|false)\b{{not_id_key_suffix}}
    #   scope: constant.language.elixir
    # - match: '(?!_){{identifier}}(?!:)(?=\s*(?>[,)=\\]|\.\.|->|$))'
    #   scope: variable.parameter.elixir
    # - match: \,
    #   scope: punctuation.separator.elixir
    - include: fn_parameters

  # fn_header:
  #   - match: (?=.+?->)
  #     push:
  #       - match: (?=->)
  #         scope: punctuation.definition.parameters.end.elixir
  #         pop: true
  #       - include: fn_parameters
  #       - include: core_syntax

  function_header_pop:
    - match: \bunquote\b{{not_id_key_suffix}}(?=\s*\()
      scope: variable.function.elixir
      set:
        - match: (?=\()
          set: [function_params_pop, arguments_pop]
    - match: '{{identifier}}(?=\s*(\(|,|do\b{{not_id_key_suffix}}|$))'
      scope: entity.name.function.elixir
      set: function_params_pop
    - match: (?=\S)
      set:
        - match: ({{operators}}|\bin\b{{not_id_key_suffix}})
          scope: entity.name.function.elixir
          set:
            - include: parameters
            - match: (?=\S|$)
              pop: true
        - match: (?=\()
          set: function_params_pop
        - include: parameters
        - match: (?=\S|$)
          pop: true

  function_params_pop:
    - match: '[^\S\n\r]'
    - match: \(
      scope: punctuation.definition.parameters.begin.elixir
      set:
        - meta_scope: meta.function.parameters.elixir
        - match: \)
          scope: punctuation.definition.parameters.end.elixir
          set: function_params_end_pop
        - include: parameters
    - include: pop_empty

  fn_parameters:
    # NB: no default parameters in fn blocks
    - match: \\\\(?!:)
      scope: keyword.operator.other.elixir invalid.illegal.default-operator.elixir
    - include: parameters

  parameters:
    - include: atom_keyword
    - include: elixir_keywords
    - match: (?!_)({{identifier}})(?=\s*(?>[,)}\]=|\\]|\.\.|::|->|\b(when|in|do)\b{{not_id_key_suffix}}|$))
      captures:
        1: variable.parameter.elixir
    - match: \,(?=\s*\))
      scope: invalid.illegal.separator.elixir
    - match: \,
      scope: punctuation.separator.elixir
    # TODO: avoid matching expressions as parametrs after \\
    # - match: \\\\(?=\s*{{identifier}})
    #   scope: keyword.operator.other.elixir
    #   push:
    #     - include: modules_identifiers
    #     - match: (?=\S)
    #       pop: true
    - match: \\\\
      scope: keyword.operator.other.elixir
    - include: tuple_param
    - include: list_param
    - include: map_param
    - include: binary_string_param
    - include: core_syntax

  tuple_param:
    - match: \{
      scope: punctuation.section.sequence.begin.elixir
      push:
        - meta_scope: meta.sequence.tuple.elixir
        - match: \}
          scope: punctuation.section.sequence.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: parameters
        - include: core_syntax

  list_param:
    - match: \[
      scope: punctuation.section.brackets.begin.elixir
      push:
        - meta_scope: meta.brackets.elixir
        - match: \]
          scope: punctuation.section.brackets.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: parameters
        - include: core_syntax

  map_param:
    - match: \%
      scope: punctuation.section.mapping.begin.elixir
      push:
        - match: \s+
        - match: (?=\b__MODULE__\b{{not_id_key_suffix}})
          set: [map_param_body_pop, map_special_form_pop]
        - match: \b_\b{{not_id_key_suffix}}
          scope: comment.underscore.elixir
          set: map_param_body_pop
        - match: (?={{module_name}})
          set: [map_param_body_pop, module_names_pop]
        - include: map_param_body_pop

  map_param_body_pop:
    - match: \s+
    - match: \{
      scope: punctuation.section.mapping.begin.elixir
      set:
        - meta_scope: meta.mapping.elixir
        - match: \}
          scope: punctuation.section.mapping.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.mapping.elixir
        - include: parameters
        - include: core_syntax
    - include: pop_empty

  binary_string_param:
    - match: '>>(?!>)'
      scope: punctuation.definition.string.binary.end.elixir invalid.illegal.elixir
    - match: <<(?!<)
      scope: punctuation.definition.string.binary.begin.elixir string.other.elixir
      push:
        - meta_scope: meta.string.binary.elixir
        - include: binary_string_body
        - include: parameters
        - include: core_syntax

  # TODO: the when clause can appear on the next line; maybe simply let core_syntax match the rest.
  function_params_end_pop:
    - include: when_params
    - match: \,
      scope: punctuation.separator.elixir
      set:
        #- include: do_block_pop
        - match: \bdo:(?!:)|$
          scope: constant.other.keyword.elixir
          pop: true
        - include: core_syntax
    - include: do_block_pop
    - match: $
      pop: true

  when_params:
    # TODO: need to break at comma; solve with with_prototype or escape?
    - match: \bwhen\b{{not_id_key_suffix}}
      scope: keyword.other.elixir
    - include: core_syntax
    - match: $
      pop: true


  numeric:
    - match: |
        (?x)
        \b(
          0x\h[\h_]* |
          0b[01](?:_?[01])* |
          0o[0-7](?:_?[0-7])* |
          \d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][-+]?\d(?:_?\d)*)?
        )(\w*)\b
      comment: (?:_?\d)* because double or trailing '_' are invalid
      captures:
        1: constant.numeric.elixir
        2: invalid.illegal.numeric.elixir

  binary_string:
    - match: '>>(?!>)'
      scope: punctuation.definition.string.binary.end.elixir invalid.illegal.elixir
    - match: <<(?!<)
      scope: punctuation.definition.string.binary.begin.elixir string.other.elixir
      push:
        - meta_scope: meta.string.binary.elixir
        - include: binary_string_body
        - include: core_syntax

  binary_string_body:
    - match: '>>(?!>)'
      scope: punctuation.definition.string.binary.end.elixir string.other.elixir
      pop: true
    - match: (\,)\s*(\,)
      captures:
        1: invalid.illegal.separator.binary.elixir
        2: invalid.illegal.separator.binary.elixir
    - match: \,
      scope: punctuation.separator.binary.elixir
    - match: '::(?!:)'
      scope: keyword.other.colon.elixir
      push:
        - match: (?:[a-z][\w-]*)\s*(?>\(\s*(?>(\d+)|({{identifier}}))?\s*\))?
          scope: storage.type.binary.elixir
          captures:
            1: constant.numeric.elixir
            2: variable.other.elixir
        - match: (?=\()
          push:
            - meta_scope: storage.type.elixir
            - include: arguments_pop
        - match: \d+|[-_*]
          scope: storage.type.binary.elixir
        - match: (?=\S)
          pop: true

  escaped_char:
    - match: \\x\h{2}
      scope: constant.character.escape.hex.elixir
    # Avoid possibly matching closing string delimiter: [^'"/)\]}>]
    - match: \\x(?:\h|([^'"/)\]}>])){1,2}
      scope: constant.character.escape.hex.elixir
      captures:
        1: invalid.illegal.escape.hex.elixir
        2: invalid.illegal.escape.hex.elixir
    - match: \\u(?:\h{4}|{\h{1,6}})
      scope: constant.character.escape.unicode.elixir
    - match: \\u(?:{}|{?[^'"/)\]}>]{1,6}}?)
      scope: invalid.illegal.escape.unicode.elixir
    - match: \\.
      scope: constant.character.escape.char.elixir

  interpolated_elixir:
    - match: (?=#{)
      push:
        # TODO: could use 1, but need to adjust scopes in rules using escaped_or_interpolated.
        - clear_scopes: true
        - match: '#{'
          scope: punctuation.section.interpolation.begin.elixir
          set:
            - clear_scopes: true
            - meta_content_scope: source.elixir.embedded
            - meta_scope: source.elixir meta.string.elixir meta.interpolation.elixir
            - match: \}
              scope: punctuation.section.interpolation.end.elixir
              pop: true
            - include: core_syntax

  escaped_or_interpolated:
    - include: escaped_char
    - include: interpolated_elixir

  regex_elixir:
    - include: scope:source.regexp.elixir

  regex_or_interpolated:
    - include: interpolated_elixir
    - include: regex_elixir


  simple_string:
    - match: "'"
      comment: single quoted string (allows for interpolation)
      scope: punctuation.definition.string.begin.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.single.elixir
        - match: "'"
          scope: punctuation.definition.string.end.elixir
          pop: true
        - include: escaped_or_interpolated

    - match: \"
      comment: double quoted string (allows for interpolation)
      scope: punctuation.definition.string.begin.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.double.elixir
        - match: \"
          scope: punctuation.definition.string.end.elixir
          pop: true
        - include: escaped_or_interpolated

  heredoc_regex_interpolated:
    - match: (""")(.*)\n
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        - include: heredoc_string_closing_double
        - match: ''
          push: regex_elixir
          with_prototype:
            - include: interpolated_elixir
            - match: (?=^.*?""")
              pop: true

    - match: (''')(.*)\n
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        - include: heredoc_string_closing_single
        - match: ''
          push: regex_elixir
          with_prototype:
            - include: interpolated_elixir
            - match: (?=^.*?''')
              pop: true

  heredoc_regex_raw:
    - match: (""")(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        # TODO: not yet committed. simplifies rules because no interpolation is needed.
        # - include: regex_elixir
        - include: heredoc_string_closing_double
        - match: ''
          push: regex_elixir
          with_prototype:
            - match: (?=^.*?""")
              pop: true

    - match: (''')(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        # TODO: not yet committed. simplifies rules because no interpolation is needed.
        # - include: regex_elixir
        - include: heredoc_string_closing_single
        - match: ''
          push: regex_elixir
          with_prototype:
            - match: (?=^.*?''')
              pop: true

  heredoc_string_interpolated:
    - match: (""")(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        - include: escaped_or_interpolated
        - include: heredoc_string_closing_double

    - match: (''')(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        - include: escaped_or_interpolated
        - include: heredoc_string_closing_single

  heredoc_string_raw:
    - match: (""")(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
        - include: heredoc_string_closing_double

    - match: (''')(.*)\n
      comment: Triple-quoted heredocs
      captures:
        1: punctuation.definition.string.begin.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
        - include: heredoc_string_closing_single

  heredoc_string_closing_double:
    - match: ^\s*([^"]*?)\s*(""")
      captures:
        1: invalid.illegal.closing-heredoc.elixir
        2: punctuation.definition.string.end.elixir
      pop: true

  heredoc_string_closing_single:
    - match: ^\s*([^']*?)\s*(''')
      captures:
        1: invalid.illegal.closing-heredoc.elixir
        2: punctuation.definition.string.end.elixir
      pop: true


  string:
    - include: heredoc_string_interpolated
    - include: simple_string

    - match: (?x) (~[a-zA-Z])\n | ~[a-zA-Z]([^{\[<(/|"'])
      comment: catch invalid sigils first
      scope: meta.string.elixir storage.type.string.elixir
      captures:
        1: invalid.illegal.sigil-string.elixir
        2: invalid.illegal.string-delimiter.elixir

    # Look for 'a' behind the closing delimiter.
    # Bracket delimiters are not matched yet: <>, {}, [] and ()
    - match: (?=~w([/|"'])(?>\\.|(?!\1).)*\1a)
      comment: highlight words as atoms
      push:
        - match: (~w)(.)
          captures:
            1: storage.type.string.elixir
            2: string.quoted.other.atom.elixir punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir
            - meta_content_scope: string.quoted.other.atom.elixir constant.other.symbol.atom.elixir
            - match: \s+
              push:
                - clear_scopes: 1
                - include: pop_empty
            - include: escaped_or_interpolated
            - match: (\2)(a)
              captures:
                1: string.quoted.other.atom.elixir punctuation.definition.string.end.elixir
                2: string.quoted.modifiers.elixir storage.type.string.elixir
              pop: true

    - match: ~L
      comment: LiveView
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^.*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double
            - match: ''
              push: scope:text.html.elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=^.*?""")
                  pop: true
    - match: ~y
      comment: YAML with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^.*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double
            - match: ''
              push: scope:source.yaml
              with_prototype:
                - include: interpolated_elixir
                - match: (?=^.*?""")
                  pop: true
    - match: ~Y
      comment: YAML raw
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^.*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double
            - match: ''
              push: scope:source.yaml
              with_prototype:
                - match: (?=^.*?""")
                  pop: true
    - match: ~j
      comment: JSON with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^.*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double
            - match: ''
              push: scope:source.json
              with_prototype:
                - include: interpolated_elixir
                - match: (?=^.*?""")
                  pop: true
    - match: ~J
      comment: JSON raw
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (""")(.*)\n
          captures:
            1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
            2: invalid.illegal.opening-heredoc.elixir
          set:
            - meta_scope: meta.string.elixir
            - match: (?=^.*?""")
              set:
                - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
                - include: heredoc_string_closing_double
            - match: ''
              push: scope:source.json
              with_prototype:
                - match: (?=^.*?""")
                  pop: true

    - match: ~r
      comment: regex sigil string with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_regex_interpolated
            - match: ''
              set: string_modifiers_and_pop
        - match: \"
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: \"
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=")
                  pop: true
        - match: \'
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: \'
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=')
                  pop: true
        - match: /
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: /
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=/)
                  pop: true
        - match: \|
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - match: \|
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=\|)
                  pop: true
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_curly
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=})
                  pop: true
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_square
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=])
                  pop: true
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_angle
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=>)
                  pop: true
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_round
            - match: ''
              push: regex_elixir
              with_prototype:
                - include: interpolated_elixir
                - match: (?=\))
                  pop: true

    - match: ~R
      comment: regex sigil string without interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_regex_raw
            - match: ''
              set: string_modifiers_and_pop
        - match: \"
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: \"
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=")
                  pop: true
        - match: \'
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: \'
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=')
                  pop: true
        - match: /
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: /
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=/)
                  pop: true
        - match: \|
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - match: \|
              set: string_modifiers_and_pop
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=\|)
                  pop: true
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_curly
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=})
                  pop: true
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_square
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=])
                  pop: true
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_angle
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=>)
                  pop: true
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.regex.elixir
            - include: string_closing_round
            - match: ''
              push: regex_elixir
              with_prototype:
                - match: (?=\))
                  pop: true

    - match: ~[a-z]
      comment: with sigil and with interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_string_interpolated
            - match: ''
              set: string_modifiers_and_pop
        - match: (?=[/|"'])
          set:
            - meta_scope: meta.string.elixir
            # (?<=[a-z]) avoids matching again after the closing delimiter. E.g.: ~s||//
            - match: (?<=[a-z])([/|"'])
              captures:
                1: string.quoted.other.literal.lower.elixir punctuation.definition.string.begin.elixir
              push:
                - meta_content_scope: string.quoted.other.literal.lower.elixir
                - match: \1
                  scope: string.quoted.other.literal.lower.elixir punctuation.definition.string.end.elixir
                  pop: true
                - include: escaped_or_interpolated
            - match: ''
              set: string_modifiers_and_pop
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_curly
            - include: escaped_or_interpolated
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_square
            - include: escaped_or_interpolated
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_angle
            - include: escaped_or_interpolated
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.interpolated.elixir
            - include: string_closing_round
            - include: escaped_or_interpolated

    - match: ~[A-Z]
      comment: with sigil and without interpolation
      scope: meta.string.elixir storage.type.string.elixir
      push:
        - match: (?="""|''')
          set:
            - include: heredoc_string_raw
            - match: ''
              set: string_modifiers_and_pop
        - match: (?=[/|"'])
          set:
            - meta_scope: meta.string.elixir
            # (?<=[A-Z]) avoids matching again after the closing delimiter. E.g.: ~S||//
            - match: (?<=[A-Z])([/|"'])
              captures:
                1: string.quoted.other.literal.upper.elixir punctuation.definition.string.begin.elixir
              push:
                - meta_content_scope: string.quoted.other.literal.upper.elixir
                - match: \1
                  scope: string.quoted.other.literal.upper.elixir punctuation.definition.string.end.elixir
                  pop: true
            - match: ''
              set: string_modifiers_and_pop
        - match: \{
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_curly
        - match: \[
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_square
        - match: \<
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_angle
        - match: \(
          scope: punctuation.definition.string.begin.elixir
          set:
            - meta_scope: meta.string.elixir string.quoted.other.literal.upper.elixir
            - include: string_closing_round

  string_closing_curly:
    - match: \}
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_closing_square:
    - match: \]
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_closing_angle:
    - match: \>
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_closing_round:
    - match: \)
      scope: punctuation.definition.string.end.elixir
      set: string_modifiers_and_pop

  string_modifiers:
    - match: '[a-zA-Z]+'
      scope: meta.string.elixir string.quoted.modifiers.elixir storage.type.string.elixir
    - match: \w+
      scope: invalid.illegal.non-ascii-modifier.elixir

  string_modifiers_and_pop:
    - include: string_modifiers
    - include: pop_empty

  def_blocks:
    - match: \bdefmodule\b{{not_id_key_suffix}}
      scope: keyword.control.module.elixir
      push:
        - meta_scope: meta.namespace.module.elixir
        - include: defmodule_1st_argument
        - match: \(
          scope: punctuation.section.arguments.begin.elixir
          push:
            - meta_scope: meta.function-call.arguments.elixir
            - include: arguments_closing_pop
            - match: \,
              scope: punctuation.separator.arguments.elixir
              set:
                - include: arguments_closing_pop
                - include: core_syntax
            - include: defmodule_1st_argument
        - match: '$'
          pop: true
    - match: \bdefprotocol\b{{not_id_key_suffix}}
      scope: keyword.control.protocol.elixir
      push:
        - meta_scope: meta.namespace.protocol.elixir
        - include: do_block_pop
        - include: module_namespaces
        - match: '$'
          pop: true
    - match: \bdefimpl\b{{not_id_key_suffix}}{{not_closing_or_operator}}
      scope: keyword.control.implementation.elixir
      push:
        - meta_scope: meta.namespace.implementation.elixir
        - match: (?=\s)
          set: arguments_ws_pop
        - include: pop_empty
    - match: \bdef(?>delegate|macro|guard|)\b{{not_id_key_suffix}}{{not_closing_or_operator}}
      scope: keyword.declaration.function.public.elixir
      push: function_header_pop
    - match: \bdef(?>delegate|macro|guard|)p\b{{not_id_key_suffix}}{{not_closing_or_operator}}
      scope: keyword.declaration.function.private.elixir
      push: function_header_pop

  defmodule_1st_argument:
    - include: do_block_pop
    # E.g.: defmodule MyApp do ... end
    - include: module_namespaces
    # E.g.: defmodule :"Elixir.ModuleTest.RawModule" do ... end
    - include: atom_symbol
    # E.g.: defmodule __MODULE__.NonAtomAlias do ... end
    - include: special_form
    # E.g.: defmodule unquote(name) do ... end
    - include: function_call
    - include: modules_identifiers

  do_block_pop:
    - match: \bdo\b{{not_id_key_suffix}}
      scope: keyword.control.elixir punctuation.section.block.begin.elixir
      set:
        - meta_scope: meta.block.elixir
        - include: block_end_pop
        - include: core_syntax

  do_block:
    # NB: Commented out due to EEx templates: <%= if x do %>...<% end %>
    # - match: \bend\b{{not_id_key_suffix}}
    #   scope: invalid.illegal.block-end.elixir
    - match: (?=\bdo\b{{not_id_key_suffix}})
      push: do_block_pop

  block_end_pop:
    - match: \bend\b{{not_id_key_suffix}}
      scope: keyword.control.elixir punctuation.section.block.end.elixir
      pop: true

  module_names:
    - match: (?={{module_name}})
      push:
        - meta_scope: meta.path.modules.elixir
        - match: '{{module_name}}'
          scope: constant.other.module.elixir
        - include: module_accessor_or_pop

  module_names_pop:
    - match: \s+(?!$)
    # - match: '[^\S\r\n]+'
    - include: module_names
    - include: pop_empty

  module_namespaces:
    # TODO: should also handle: defmodule :"Elixir.ModuleTest.RawModule" do ... end
    - match: (?={{module_name}}|:{{atom_id}})
      push:
        - meta_scope: meta.namespace.elixir
        - match: (?=:{{atom_id}}\s*\.)
          push:
            - include: atom_symbol
            - match: (?=\.)
              pop: true
        - match: '{{module_name}}(?=\s*\.)'
          scope: constant.other.module.elixir
        - match: '(:)({{atom_id}})'
          scope: constant.other.symbol.elixir
          captures:
            1: punctuation.definition.constant.begin.elixir
            2: entity.name.namespace.elixir
        - match: '{{module_name}}'
          scope: entity.name.namespace.elixir
        - include: module_accessor_or_pop

  module_accessor_or_pop:
    - match: \s+(?!$)
    - match: \.
      scope: punctuation.accessor.elixir
    - include: pop_empty

  modules_identifiers:
    - match: (?={{module_name}}|{{identifier}})
      push:
        - meta_scope: meta.path.modules-identifiers.elixir
        # TODO: rewrite: need to pop or set next rule after match
        - match: (?=(?>{{identifier}}|{{operators}})(?=(\s*\.\s*)?\())
          pop: true
        # TODO: handle A.B.c
        # - match: ({{module_name}})\s*(\.)\s*({{identifier}}|{{operators}})
        - match: '{{module_name}}'
          scope: constant.other.module.elixir
        # E.g.: def member?(_.._, _value)
        - match: '(?<![^.]\.)_{{identifier}}?'
          scope: variable.other.unused.elixir
        - match: '{{identifier}}'
          scope: variable.other.elixir
        - match: \s*\.(?!\.)
          scope: punctuation.accessor.dot.elixir
          set:
            # E.g.: Kernel.++([], [])
            - match: (?>{{identifier}}|{{operators}})(?=(\s*\.\s*)?\()
              scope: variable.function.elixir
              set:
                - match: (?=\()
                  set: arguments_pop
                - match: \.(?!\.)
                  scope: punctuation.accessor.dot.elixir
                  pop: true
            - match: '{{identifier}}|{{operators}}'
              scope: variable.other.elixir
            - include: modules_identifiers
            - include: pop_empty
            # - match: (?=\S|$)
            #   pop: true
        - include: pop_empty
        # NB: highlights every id after the first one as an id, e.g.: "x end"
        # - match: (?=\S|$)
        #   pop: true

  doc_attribute:
    # @(module)?doc\s+(?!"|'|since:|guard:|deprecated:|authors:|false|~S"|~S')
    - match: (@)((?>module|type)?doc)\b{{not_id_key_suffix}}{{not_closing_or_operator}}
      captures:
        1: keyword.operator.attribute.elixir
        2: comment.line.doc-keyword.elixir
      push:
        - match: \s+
          set:
            # TODO: correct scope? use comment.line below for "..."?
            - meta_scope: comment.block.documentation.elixir
            - include: markdown_comment
            - match: (?=\S|$)
              pop: true

  markdown_comment:
    - match: (""")(.*)\n
      captures:
        1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: (?=^\s*""")
          set:
            - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
            - include: heredoc_string_closing_double
        - include: escaped_or_interpolated
        - include: iex_prompt
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?=^\s*"""|(?<=\s{4})(?:iex.*?>|def(?>module|macro|p|)\b{{not_id_key_suffix}})|\\|#{)

    - match: \"
      scope: punctuation.definition.string.begin.elixir string.quoted.double.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: \"
          scope: punctuation.definition.string.end.elixir string.quoted.double.elixir
          pop: true
        - include: escaped_or_interpolated
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?="|\\|#{)

    - match: ~S(""")(.*)\n
      scope: meta.string.elixir storage.type.string.elixir
      captures:
        1: punctuation.definition.string.begin.elixir string.quoted.triple.double.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: (?=^\s*""")
          set:
            - meta_scope: meta.string.elixir string.quoted.triple.double.elixir
            - include: heredoc_string_closing_double
        - include: iex_prompt
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?=^\s*"""|(?<=\s{4})(?:iex.*?>|def(?>module|macro|p|)\b{{not_id_key_suffix}}))

    - match: ~S(''')(.*)\n
      scope: meta.string.elixir storage.type.string.elixir
      captures:
        1: punctuation.definition.string.begin.elixir string.quoted.triple.single.elixir
        2: invalid.illegal.opening-heredoc.elixir
      push:
        - meta_scope: meta.string.elixir
        - match: (?=^\s*''')
          set:
            - meta_scope: meta.string.elixir string.quoted.triple.single.elixir
            - include: heredoc_string_closing_single
        - include: iex_prompt
        - match: ''
          embed: scope:text.html.markdown
          embed_scope: text.html.elixir source.elixir.embedded.html
          escape: (?=^\s*'''|(?<=\s{4})(?:iex.*?>|def(?>module|macro|p|)\b{{not_id_key_suffix}}))

  iex_prompt:
    - match: (?<=\s{4})(?=\bdef(?>module|macro|p|)\b{{not_id_key_suffix}})
      push:
        - clear_scopes: true
        - meta_scope: meta.interpolation.elixir markup.raw.block.markdown markup.raw.block.elixir
        - include: scope:source.elixir
        - match: $\s
          scope: markup.raw.block.elixir
          pop: true
    - match: (?<=\s{4})(iex).*?(>)
      captures:
        1: keyword.other.elixir
        2: keyword.other.elixir
      push:
        - clear_scopes: true
        - meta_scope: meta.interpolation.elixir markup.raw.block.markdown markup.raw.block.elixir
        # NB: needs with_prototype or embed to work
        - match: ^\s*(\.{3})(>)
          scope: keyword.other.elixir
        - include: scope:source.elixir
        - match: $\s
          scope: markup.raw.block.elixir
          pop: true

  operator:
    - match: '::'
      scope: keyword.operator.colon.elixir
    - match: <~
      scope: keyword.operator.arrow-tilde.elixir
    - match: <-|->
      scope: keyword.operator.arrow.elixir
    - match: <>
      scope: keyword.operator.binary-concatenation.elixir
    - match: \|>
      scope: keyword.operator.pipe.elixir
    - match: \+\+|--
      scope: keyword.operator.list.elixir
    - match: \.{3}
      comment: can appear in @type declarations
      scope: keyword.operator.ellipsis.elixir
    - match: \.\.
      scope: keyword.operator.range.elixir
    - match: =>
      scope: keyword.operator.map-pair.elixir
    - match: (?>\|\|\||&&&|\^\^\^|<<<|>>>|~~~)
      scope: keyword.operator.bitwise.elixir
    - match: \|
      scope: keyword.operator.cons.elixir
    - match: \\\\
      scope: keyword.operator.default.elixir
    - match: (?>[!=]=|[<>])=?
      scope: keyword.operator.comparison.elixir
    - match: \b(?>not|and|or|xor)\b{{not_id_key_suffix}}|!|\|\||&&
      scope: keyword.operator.logical.elixir
    - match: '[-+*/]'
      scope: keyword.operator.arithmetic.elixir
    - match: =
      scope: keyword.operator.assignment.elixir
    - match: ;
      scope: keyword.operator.semicolon.elixir
    - match: \^
      scope: keyword.operator.pin.elixir

  tuple:
    - match: \}
      scope: invalid.illegal.stray-closing-brace.elixir
    - match: \{
      scope: punctuation.section.sequence.begin.elixir
      push:
        - meta_scope: meta.sequence.tuple.elixir
        - match: \}
          scope: punctuation.section.sequence.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: core_syntax

  list:
    - match: \]
      scope: invalid.illegal.stray-closing-bracket.elixir
    - match: \[
      scope: punctuation.section.brackets.begin.elixir
      push:
        - meta_scope: meta.brackets.elixir
        - match: \]
          scope: punctuation.section.brackets.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.sequence.elixir
        - include: core_syntax

  map:
    - match: \%
      scope: punctuation.section.mapping.begin.elixir
      push:
        - match: \s+
        - match: (?=\b__MODULE__\b{{not_id_key_suffix}})
          set: [map_body_pop, map_special_form_pop]
        - match: \b_\b{{not_id_key_suffix}}
          scope: comment.underscore.elixir
          set: map_body_pop
        - match: (?={{module_name}})
          set: [map_body_pop, module_names_pop]
        - include: map_body_pop

  map_special_form_pop:
    - include: special_form
    - include: pop_empty

  map_body_pop:
    - match: \s+
    - match: \{
      scope: punctuation.section.mapping.begin.elixir
      set:
        - meta_scope: meta.mapping.elixir
        - match: \}
          scope: punctuation.section.mapping.end.elixir
          pop: true
        - match: \,
          scope: punctuation.separator.mapping.elixir
        - include: core_syntax
    - include: pop_empty

  parens:
    - match: \)
      scope: invalid.illegal.stray-closing-parenthesis.elixir
    - match: \(
      scope: punctuation.section.parens.begin.elixir
      push:
        - meta_scope: meta.parens.elixir
        - match: \)
          scope: punctuation.section.parens.end.elixir
          pop: true
        - include: core_syntax

  alias:
    - match: \balias\b(?={{not_closing_or_operator}})
      scope: keyword.control.elixir
      push:
        - match: \s+
        - include: alias_names
        - include: alias_arg
        - match: \,
          scope: punctuation.separator.arguments.elixir
        - include: core_syntax
        - match: $
          pop: true

  alias_arg:
    - match: \,(?=\s*as:(?!:))
      scope: punctuation.separator.arguments.elixir
      push:
        - match: \bas:(?!:)
          scope: constant.other.keyword.elixir
          set:
            - match: \s+
            - match: '{{module_name}}'
              scope: entity.name.namespace.elixir
            - include: pop_empty

  alias_names:
    - match: (?=(?>{{module_name}}|\b__MODULE__\b){{not_id_key_suffix}})
      push:
        - meta_scope: meta.path.modules.elixir
        - match: \b(__MODULE__)\b
          scope: variable.language.elixir
        - match: '{{module_name}}'
          scope: constant.other.module.elixir
        - match: (?<=\.)\s*\{
          scope: punctuation.section.braces.begin.elixir
          push:
            - match: \}
              scope: punctuation.section.braces.end.elixir
              pop: true
            - match: \,
              scope: punctuation.separator.sequence.elixir
            - include: alias_names_scoped
        - match: \.
          scope: punctuation.accessor.elixir
        - match: \s+
        - match: $|(?=,)
          pop: true

  alias_names_scoped:
    - match: (?={{module_name}})
      push:
        - meta_scope: meta.alias-names.elixir
        - match: '{{module_name}}'
          scope: constant.other.module.elixir
        - match: \{
          scope: punctuation.section.braces.begin.elixir
          push:
            - match: \}
              scope: punctuation.section.braces.end.elixir
              pop: true
            - match: \,
              scope: punctuation.separator.sequence.elixir
            - include: alias_names_scoped
        - match: \.
          scope: punctuation.accessor.elixir
        - match: \s+
        - match: (?=})
          pop: true

  atom_keyword:
    - match: (?>\*\*|\[\]|\^\^|\.)(:)(?!:)
      scope: invalid.illegal.atom-keyword.elixir
      captures:
        1: punctuation.definition.constant.elixir

    - match: (?>{{atom_id}}|{{module_name}}|{{identifier}}|{{atom_ops}}|{{operators}})(:)(?!:)
      comment: keyword symbol
      scope: constant.other.keyword.elixir
      captures:
        1: punctuation.definition.constant.elixir

    # - match: (['"])((?:[^#](?!{)++)|#{\k<2>})*\1(?=:)
    # - match: ( \( ( [^()]++ | \k<1> )* \) )
    # Look for ':' behind the closing apostrophe.
    - match: (?=(["'])(?>\\.|(?!\1).)*\1:(?!:))
      comment: keyword string
      push:
        - match: (.)
          scope: punctuation.definition.constant.begin.regexp.elixir
          set:
            - meta_scope: constant.other.keyword.double-quoted.elixir
            - include: escaped_or_interpolated
            - match: '\1:'
              scope: punctuation.definition.constant.end.regexp.elixir
              pop: true

  atom_symbol:
    - match: (:)(?>{{atom_id}}|{{atom_ops}}|{{operators}})
      comment: atom symbols
      scope: constant.other.symbol.elixir
      captures:
        1: punctuation.definition.constant.begin.elixir
    - match: :'
      scope: punctuation.definition.constant.begin.elixir
      push:
        - meta_scope: constant.other.symbol.single-quoted.elixir
        - match: \'
          scope: punctuation.definition.constant.end.elixir
          pop: true
        - include: escaped_or_interpolated
    - match: :"
      scope: punctuation.definition.constant.begin.elixir
      push:
        - meta_scope: constant.other.symbol.double-quoted.elixir
        - match: \"
          scope: punctuation.definition.constant.end.elixir
          pop: true
        - include: escaped_or_interpolated

  capture:
    - match: \&0
      scope: invalid.illegal.capture.elixir
    - match: \&\d+
      scope: constant.other.capture.elixir
    - match: \&(?=\s*(?>{{module_name}}\s*\.\s*)*(?>{{identifier}}|{{operators}})\s*/\s*\d)
      scope: keyword.operator.capture.elixir
      push:
        - match: (/)\s*(\d+)
          captures:
            1: punctuation.accessor.slash.elixir
            2: constant.numeric.integer.decimal.elixir
          pop: true
        - include: module_names
        - match: '{{identifier}}|{{operators}}'
          scope: variable.other.capture.elixir
    - match: \&
      scope: keyword.operator.capture.elixir

  sql_fragment:
    # See: https://github.com/sublimehq/Packages/blob/3b1923b025db53d67d4fde4baf1360a0c76d7469/SQL/SQL.sublime-syntax#L188
    - match: \b(fragment)\s*(\()
      captures:
        1: support.function.elixir
        2: punctuation.section.parens.begin.elixir
      push:
        - match: \)
          scope: punctuation.section.parens.end.elixir
          pop: true
        # TODO: handle triple quoted strings.
        - match: '"""\n'
          scope: punctuation.definition.string.begin.elixir string.quoted.double.elixir
          push:
            - match: ''
              set: scope:source.sql
              with_prototype:
                - include: sql_embedded
                - match: '"""'
                  scope: punctuation.definition.string.end.elixir string.quoted.double.elixir
                  pop: true
        - match: \"
          scope: punctuation.definition.string.begin.elixir string.quoted.double.elixir
          push:
            - match: ''
              set: scope:source.sql
              with_prototype:
                - include: sql_embedded
                - match: \"
                  scope: punctuation.definition.string.end.elixir string.quoted.double.elixir
                  pop: true
        - include: core_syntax

  sql_embedded:
    - match: |
        (?x)
        \b(
          jsonb_to_tsvector|to_jsonb?|(?>array|row)_to_json|jsonb?_build_array|jsonb?(?:_build)?_object |
          jsonb?_(?>array_(?>length|elements(?:_text)?)|each(?:_text)?|extract_path(?:_text)?|object_keys|populate_record(?:set)?|typeof|to_record(?:set)?|strip_nulls) |
          jsonb_(?>set|insert|pretty|path_exists|path_match|path_query(?>_array|_first)?)
        )\b
      scope: support.function.sql
    - match: '(?i)\b(now|(?>array|string|jsonb?)_agg|random|row_number|to_tsquery|to_tsvector|setweight|replace)\b'
      scope: support.function.sql
    - match: '(?i)\b(ANY|OVER|NOT\s+IN|NULLS\s+LAST)\b|::'
      scope: keyword.operator.sql
    - match: '(?<=::)(jsonb?|tsvector)\b'
      scope: storage.type.sql
    - match: ->>?|#>>?|@[>@?]|<@|#-
      comment: Postgres jsonb operators
      scope: keyword.operator.jsonb.sql
    - match: (\\\\)(\?[|&]?)?
      comment: Postgres jsonb operators
      captures:
        1: constant.character.escape.sql
        2: keyword.operator.jsonb.sql
    - match: (?<!\w)\\?\?(?!\w)
      comment: Ecto argument placeholder
      scope: constant.other.placeholder.elixir

  comment:
    - match: (##).*
      scope: comment.line.number-sign.section.elixir
      captures:
        1: punctuation.definition.comment.elixir
    - match: (#).*
      scope: comment.line.number-sign.elixir
      captures:
        1: punctuation.definition.comment.elixir

  char_literal:
    - match: \?$
      scope: invalid.illegal.character-literal.elixir
    - match: \?(?>\\(?>.|\n)|\S|(\s))
      comment: character literal as an integer
      scope: constant.numeric.elixir
      captures:
        1: invalid.illegal.character-literal.elixir

  built-ins:
    - match: |
        (?x)
        (?>
          is_(?>atom|binary|bitstring|boolean|float|function|integer|list|map|nil|number|pid|port|record|reference|tuple|exception) |
          abs|bit_size|byte_size|div|elem|hd|length|map_size|node|rem|round|tl|trunc|tuple_size
        )\b(?=\s*\(|{{not_closing_or_operator}})
      scope: variable.function.built-in.elixir
      push:
        - match: (?=\()
          set: [arguments_pop, spaces_pop]
        - include: arguments_ws_pop
        - include: pop_empty

  function_call:
    - include: built-ins
    - match: '{{identifier}}(?=\s*\.?\s*\(|{{not_closing_or_operator}})'
      scope: variable.function.elixir
      push:
        - match: \s*(\.)(?!\.)
          captures:
            # TODO: better scope?
            1: punctuation.accessor.dot.elixir
        - match: (?=\()
          set: [arguments_pop, spaces_pop]
        - include: arguments_ws_pop
        - include: pop_empty
    - match: ({{module_name}})\s*(\.)\s*({{identifier}}|{{operators}})
      comment: always a function call after a module
      captures:
        1: constant.other.module.elixir
        2: punctuation.accessor.dot.elixir
        3: variable.function.elixir
      push:
        # NB: no \s* before \(
        - match: (?=\()
          set: arguments_pop
        - match: (?=\s)
          set: arguments_ws_pop
        - include: pop_empty

  arguments_pop:
    - match: \(
      scope: punctuation.section.arguments.begin.elixir
      set:
        - meta_scope: meta.function-call.arguments.elixir
        - include: arguments_closing_pop
        - match: \,
          scope: punctuation.separator.arguments.elixir
        - include: core_syntax

  arguments_closing_pop:
    - match: \)
      scope: punctuation.section.arguments.end.elixir
      pop: true

  arguments_ws_pop:
    - match: \s
      comment: arguments list without parentheses
      scope: punctuation.section.arguments.begin.elixir
      set:
        - meta_scope: meta.function-call.arguments.elixir
        - match: (\,)(?=\s*do\b{{not_id_key_suffix}})
          scope: invalid.illegal.separator.arguments.elixir
        - match: (\,)(?:\s*$)?
          captures:
            1: punctuation.separator.arguments.elixir
        # NB: needed due to "... #{inspect x} ..." or Repo.all(from p in q, select: p.title)
        - match: '[\n\r]|(?=[})\];]|%>|\b(?>else|end)\b{{not_id_key_suffix}})'
          scope: punctuation.section.arguments.end.elixir
          pop: true
        - match: (?=\bdo\b{{not_id_key_suffix}})
          set: do_block_pop
        - match: (?={{identifier}}\s+do\b)
          set:
            - include: modules_identifiers
            - include: pop_empty
        - include: core_syntax

  spaces_pop:
    - match: \s*
      pop: true

  # TODO: remove?
  # variable:
  #   - match: '_{{identifier}}'
  #     scope: variable.other.elixir comment.variable.elixir
  #   - match: '{{identifier}}'
  #     scope: variable.other.elixir

  dot_accessor:
    - match: \.(?!\.)
      scope: punctuation.accessor.dot.elixir
      push:
        - match: '(?>{{identifier}}|{{operators}})?(?=\s*\()'
          scope: variable.function.elixir
          set: [arguments_pop, spaces_pop]
        - match: '{{identifier}}|{{operators}}'
          scope: variable.other.member.elixir
          pop: true
        - match: (?=\S)
          pop: true

  special_form:
    - match: \b(__(?>CALLER|ENV|MODULE|DIR|STACKTRACE)__)\b(?![?!])
      scope: variable.language.special-form.elixir

  special_attributes:
    - include: doc_attribute

    - match: (@)(derive|deprecated|impl|file|behaviour|vsn|(?>before_|after_)?compile|dialyzer|external_resource|on_(?>definition|load))\b{{not_id_key_suffix}}{{not_closing_or_operator}}
      captures:
        1: keyword.operator.attribute.elixir
        2: keyword.other.elixir

    - match: (@)(spec|typep?|opaque|(?:macro)?callback)\b{{not_id_key_suffix}}{{not_closing_or_operator}}
      captures:
        1: keyword.operator.attribute.elixir
        2: keyword.declaration.type.elixir
      push:
        - match: '{{identifier}}'
          scope: entity.name.type.elixir
          pop: true
        - match: (?=\S)
          pop: true

  module_attribute:
    - match: (@)({{identifier}}){{not_closing_or_operator}}
      comment: definition
      captures:
        1: keyword.operator.attribute.elixir
        2: entity.name.constant.elixir variable.other.constant.elixir
    - match: (@)({{identifier}}){{not_id_key_suffix}}
      comment: reference
      captures:
        1: keyword.operator.attribute.elixir
        2: variable.other.attribute.elixir
    - match: (@)(([A-Z]){{identifier}}?){{not_id_key_suffix}}
      captures:
        1: keyword.operator.attribute.elixir
        2: variable.other.attribute.elixir
        3: invalid.illegal.attribute.elixir

  elixir_keywords:
    - match: \b(?>when|not|in|fn|catch|after|rescue|do|else|end)\b(?![?!])
      comment: fully reserved keywords
      scope: keyword.control.elixir
    - match: \b(?>nil|true|false)\b(?![?!])
      scope: constant.language.elixir

  elixir_functions:
    # \b(?>case|...)\b(?!\.)(?=\s+do\b|{{not_closing_or_operator}})
    - match: \b(?>case|for|if|cond|unless|try|receive|defrecord|defstruct|defexception|defoverridable|exit|raise|reraise|throw|import|require|use|quote|unquote|super|with)\b{{not_closing_or_operator}}
      scope: keyword.control.elixir
      push: arguments_ws_pop

  pop_empty:
    - match: ''
      pop: true

  core_syntax:
    - include: atom_keyword
    - include: atom_symbol
    - include: numeric
    - include: binary_string
    - include: string
    - include: def_blocks
    - include: do_block
    - include: fn_block
    - include: tuple
    - include: parens
    - include: list
    - include: map
    - include: operator
    - include: capture

    - include: dot_accessor

    - include: alias
    - include: elixir_keywords
    - include: elixir_functions

    - include: special_form
    - include: sql_fragment
    - include: function_call
    - include: special_attributes
    - include: module_attribute
    - include: modules_identifiers
    - include: comment
    # - include: variable
    - include: char_literal
