# SYNTAX TEST "HTML (Surface).sublime-syntax"

<Rating :let={value: value, max: max} id="rating_2">
#                                        ^^^^^^^^^^ string.quoted.double
#                                       ^ punctuation.separator.key-value
#                                     ^^ entity
#                                   ^ meta.string.html meta.interpolation.html punctuation.section.interpolation.end.elixir - source
#                           ^^^^ constant.other.keyword
#             ^^^^^^ constant.other.keyword
#             ^^^^^^^^^^^^^^^^^^^^^^ meta.string.html meta.interpolation.html source.elixir.interpolated.html
#            ^ meta.string.html meta.interpolation.html punctuation.section.interpolation.begin.elixir - source
#^^^^^^ entity.name.tag.begin.surface
  {#for i <- 1..max}
#      ^^^^^^^^^^^^ source.elixir.embedded.html meta.function-call.arguments.elixir
#   ^^^ keyword.control.loop.surface
# ^^^^^^^^^^^^^^^^^^ meta.embedded.surface
    <span class={:icon, "has-text-warning": i <= value}>
      <i class="fas fa-{@icon_name}" />
#                                  ^ meta.attribute-with-value.class.html meta.string.html - meta.interpolation
#                                 ^ punctuation.section.interpolation.end.elixir - source
#                        ^^^^^^^^^ variable.other.constant.elixir
#                       ^ keyword.operator.attribute.elixir
#                       ^^^^^^^^^^ source.elixir.interpolated.html
#                      ^ punctuation.section.interpolation.begin.elixir - source
#                      ^^^^^^^^^^^^ meta.attribute-with-value.class.html meta.class-name.html meta.string.html meta.interpolation.html
#              ^^^^^^^^ meta.attribute-with-value.class.html meta.string.html - meta.interpolation
    </span>
    {i + 1}
#         ^ punctuation.section.embedded.end.surface - source
#    ^^^^^ source.elixir.embedded.html
#   ^ punctuation.section.embedded.begin.surface - source
#   ^^^^^^^ meta.embedded.surface
  {#else}
#   ^^^^ keyword.control.conditional.surface
  {#elsei}
#   ^^^^^ keyword.control.surface
  {#elseif x == 0}
#                ^ punctuation.section.embedded.end.surface
#          ^^^^^^ source.elixir.embedded.html
#   ^^^^^^ keyword.control.conditional.surface
# ^^ punctuation.section.embedded.begin.surface
# ^^^^^^^^^^^^^^^^ meta.embedded.surface
  {/for}
#      ^ punctuation.section.embedded.end.surface
#   ^^^ keyword.control.loop.surface
# ^^ punctuation.section.embedded.begin.surface
# ^^^^^^ meta.embedded.surface
</Rating>
# ^^^^^^ entity.name.tag.end.surface

<Some.component x={y} />
#     ^^^^^^^^^ variable.function.surface -entity.name
#^^^^^^^^^^^^^^^^^^^^^^^ meta.tag.other.surface
<Some.App.Component x={y}>
#         ^^^^^^^^^ entity.name.tag.begin.surface
#        ^ punctuation.accessor.dot.surface
#     ^^^ entity.name.tag.begin.surface
#    ^ punctuation.accessor.dot.surface
#^^^^ entity.name.tag.begin.surface
#^^^^^^^^^^^^^^^^^^^^^^^^^ meta.tag.other.surface
  {#case @value}
#         ^^^^^ variable.other.constant.elixir
#   ^^^^ keyword.control.conditional.surface
#              ^ punctuation.section.embedded.end.surface
# ^^punctuation.section.embedded.begin.surface
# ^^^^^^^^^^^^^^ meta.embedded.surface
    {#match [{_, first} | _]}
#                           ^ punctuation.section.embedded.end.surface
#                     ^ punctuation.section.sequence.end.elixir
#                ^^^^^ variable.parameter.elixir
#            ^ punctuation.section.sequence.begin.elixir
#   ^^ punctuation.section.embedded.begin.surface
      First {first}
#                 ^ punctuation.section.embedded.end.surface - source
#            ^^^^^ source.elixir.embedded.html variable.other.elixir
#           ^ punctuation.section.embedded.begin.surface - source
#           ^^^^^^^ meta.embedded.surface
    {#match []}
#           ^^ meta.brackets.elixir
      Value is empty
    {#match _}
#           ^ variable.parameter.unused.elixir
      Value is something else
  {/case}
</Some.App.Component >
#                    ^ punctuation.definition.tag.end.html
#                   ^ -punctuation.definition.tag.end.html
#          ^^^^^^^^^ entity.name.tag.end.surface
#         ^ punctuation.accessor.dot.surface
#      ^^^ entity.name.tag.end.surface
#     ^ punctuation.accessor.dot.surface
# ^^^^ entity.name.tag.end.surface
#^^^^^^^^^^^^^^^^^^^^^ meta.tag.other.surface

<Card {=@prop} prop={@prop}>
#                         ^ punctuation.section.interpolation.end.elixir
#                     ^^^^ variable.other.constant.elixir
#                    ^ keyword.operator.attribute.elixir
#                    ^^^^^ source.elixir.interpolated.html
#                   ^ punctuation.section.interpolation.begin.elixir
#                  ^ punctuation.separator.key-value.html
#              ^^^^ entity.other.attribute-name.html
#            ^ punctuation.section.interpolation.end.elixir
#        ^^^^ variable.other.constant.elixir
#       ^ keyword.operator.attribute.elixir
#      ^ keyword.operator.match.elixir
#      ^^^^^^ source.elixir.interpolated.html
#     ^ punctuation.section.interpolation.begin.elixir
</Card>

<#slot :args={value: @value, max: @max} />
#                                     ^ punctuation.section.interpolation.end.elixir
#             ^^^^^^^^^^^^^^^^^^^^^^^^ source.elixir.interpolated.html
#            ^ punctuation.section.interpolation.begin.elixir
#            ^^^^^^^^^^^^^^^^^^^^^^^^^^ meta.attribute-with-value.id.html meta.toc-list.id.html meta.string.html meta.interpolation.html - string
#           ^ punctuation.separator.key-value.html
#       ^^^^ entity.other.attribute-name.surface
#      ^ punctuation.definition.attribute.begin.surface
#      ^^^^^^ meta.tag.other.surface meta.attribute-with-value.id.html - meta.string - meta.interpolation
#^^^^^ entity.name.tag.begin.surface
#^^^^^^ meta.tag.other.surface - meta.attribute-with-value

<:slot></:slot>
#        ^^^^^ entity.name.tag.end.surface
#^^^^^ entity.name.tag.begin.surface
#^^^^^^^^^^^^^^ meta.tag.other.surface - meta.attribute-with-value

  <#Raw>
#      ^ punctuation.definition.tag.end.html
#  ^^^^ entity.name.tag.begin.surface
# ^ punctuation.definition.tag.begin.html
# ^^^^^^ meta.tag.other.surface - meta.attribute-with-value
  <#Raw>
#      ^ -punctuation.definition.tag.end.html
#  ^^^^ -entity.name.tag.begin.surface
# ^ -punctuation.definition.tag.begin.html
    <:slot args={@args}></:slot>
#                         ^^^^^ -entity.name
#          ^^^^^^^^^^^^ -variable -entity -punctuation
#    ^^^^^ -entity.name
    <span style="{@style}" {=@prop}></span>
#                                     ^^^^ entity.name.tag.inline.any.html
#                ^^^^^^^^ -source.elixir.interpolated
#    ^^^^ entity.name.tag.inline.any.html
  </#Raw>
#       ^ punctuation.definition.tag.end.html
#   ^^^^ entity.name.tag.end.surface
# ^^ punctuation.definition.tag.begin.html
# ^^^^^^^ meta.tag.other.surface - meta.attribute-with-value

  <#Markdown class="content" opts={x: "y"}>
#                                         ^ punctuation.definition.tag.end.html
#                                         ^ meta.tag.other.surface - meta.attribute-with-value
#                                        ^ punctuation.section.interpolation.end.elixir - source
#                                  ^^^^^^ source.elixir.interpolated.html
#                                 ^ punctuation.section.interpolation.begin.elixir - source
#                            ^^^^^^^^^^^^^ meta.tag.other.surface meta.attribute-with-value.html
#                           ^ meta.tag.other.surface - meta.attribute-with-value
#                  ^^^^^^^^^ string.quoted.double.html
#            ^^^^^^^^^^^^^^^ meta.tag.other.surface meta.attribute-with-value.class.html
#            ^^^^^ entity.other.attribute-name.class.html
#  ^^^^^^^^^ entity.name.tag.begin.surface
# ^ punctuation.definition.tag.begin.html
# ^^^^^^^^^^^ meta.tag.other.surface - meta.attribute-with-value
  # Markdown
<#Markdown>
#^^^^^^^^^ -entity.name.tag.end.surface
</#Markdown>
# ^^^^^^^^^ entity.name.tag.end.surface
#^^^^^^^^^^^ meta.tag.other.surface
#           ^ - meta.tag
    <span></span>
#           ^^^^ entity.name.tag.inline.any.html
#    ^^^^ entity.name.tag.inline.any.html
  </#Markdown>
#             ^ - meta.tag
#            ^ punctuation.definition.tag.end.html
#   ^^^^^^^^^ entity.name.tag.end.surface
# ^^ punctuation.definition.tag.begin.surface
# ^^^^^^^^^^^^ meta.tag.other.surface

<style>
  .class {
    margin: 1em;
#   ^^^^^^^^^^^^^ text.html.surface source.css.embedded.html meta.property-list.css meta.block.css
  }
</style>

<script>
  var x = { y: z };
# ^^^^^^^^^^^^^^^^^^ text.html.surface source.js.embedded.html -source.elixir
</script>

<!-- <#Markdown></#Markdown> -->
#                 ^^^^^^^^^ -entity
#     ^^^^^^^^^ -entity
<!-- This {comment} will be sent to the browser -->
#                 ^ punctuation.section.interpolation.end.elixir - source
#          ^^^^^^^ source.elixir.interpolated.html variable.other.elixir
#         ^ punctuation.section.interpolation.begin.elixir - source
#         ^^^^^^^^^ meta.interpolation.html
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ comment.block.html
 {!-- This {comment} won't be sent to the browser --}
#                                                 ^^^ punctuation.definition.comment.end.surface
#^^^^ punctuation.definition.comment.begin.surface
#^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ text.html.surface meta.embedded.html comment.block.surface - source - variable

<{}}>{@x}</{}}>
#          ^^^ entity.name.tag.end.html
#     ^^ source.elixir.embedded.html
#^^^ entity.name.tag.begin.html
<...>{@x}</...>
#          ^^^ entity.name.tag.end.html
#     ^^ source.elixir.embedded.html
#^^^ entity.name.tag.begin.html
<{x}>{@x}</{x}>
#          ^^^ entity.name.tag.end.html -source.elixir
#      ^ variable.other.constant.elixir
#     ^^ source.elixir.embedded.html
#     ^ keyword.operator.attribute.elixir
#^^^ entity.name.tag.begin.html -source.elixir

<.not_a_func>
#^^^^^^^^^^^ entity.name.tag.begin.html -variable.function
</.not_a_func>
# ^^^^^^^^^^^ entity.name.tag.end.html -variable.function
